// Generated by Hebron at 8/26/2025 5:51:53 PM

using System;
using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace PlMpegSharp
{
	unsafe partial class PlMpeg
	{
		public delegate void plm_video_decode_callback(plm_t arg0, plm_frame_t plane, object user);
		public delegate void plm_audio_decode_callback(plm_t arg0, plm_samples_t samples, object user);
		public delegate void plm_buffer_load_callback(plm_buffer_t buffer, object user);
		public delegate void plm_buffer_seek_callback(plm_buffer_t buffer, ulong offset, object user);
		public delegate ulong plm_buffer_tell_callback(plm_buffer_t buffer, object user);

		public static plm_t plm_create_with_memory(byte* bytes, ulong length, int free_when_done)
		{
			plm_buffer_t buffer = plm_buffer_create_with_memory(bytes, (ulong)(length), (int)(free_when_done));
			return plm_create_with_buffer(buffer, (int)(1));
		}
		public static plm_t plm_create_with_buffer(plm_buffer_t buffer, int destroy_when_done)
		{
			plm_t self = new plm_t();

			self.demux = plm_demux_create(buffer, (int)(destroy_when_done));
			self.video_enabled = (int)(1);
			self.audio_enabled = (int)(1);
			plm_init_decoders(self);
			return self;
		}
		public static void plm_destroy(plm_t self)
		{
			if ((self.video_decoder) != null)
			{
				plm_video_destroy(self.video_decoder);
			}

			if ((self.audio_decoder) != null)
			{
				plm_audio_destroy(self.audio_decoder);
			}

			plm_demux_destroy(self.demux);

		}
		public static int plm_has_headers(plm_t self)
		{
			if (plm_demux_has_headers(self.demux) == 0)
			{
				return (int)(0);
			}

			if (plm_init_decoders(self) == 0)
			{
				return (int)(0);
			}

			if ((((self.video_decoder) != null) && (plm_video_has_header(self.video_decoder) == 0)) || (((self.audio_decoder) != null) && (plm_audio_has_header(self.audio_decoder) == 0)))
			{
				return (int)(0);
			}

			return (int)(1);
		}
		public static int plm_probe(plm_t self, ulong probesize)
		{
			int found_streams = (int)(plm_demux_probe(self.demux, (ulong)(probesize)));
			if (found_streams == 0)
			{
				return (int)(0);
			}

			self.has_decoders = (int)(0);
			self.video_packet_type = (int)(0);
			self.audio_packet_type = (int)(0);
			return (int)(plm_init_decoders(self));
		}
		public static int plm_get_video_enabled(plm_t self)
		{
			return (int)(self.video_enabled);
		}
		public static void plm_set_video_enabled(plm_t self, int enabled)
		{
			self.video_enabled = (int)(enabled);
			if (enabled == 0)
			{
				self.video_packet_type = (int)(0);
				return;
			}

			self.video_packet_type = (int)((((plm_init_decoders(self)) != 0) && ((self.video_decoder) != null)) ? PLM_DEMUX_PACKET_VIDEO_1 : 0);
		}
		public static int plm_get_num_video_streams(plm_t self)
		{
			return (int)(plm_demux_get_num_video_streams(self.demux));
		}
		public static int plm_get_width(plm_t self)
		{
			return (int)((((plm_init_decoders(self)) != 0) && ((self.video_decoder) != null)) ? plm_video_get_width(self.video_decoder) : 0);
		}
		public static int plm_get_height(plm_t self)
		{
			return (int)((((plm_init_decoders(self)) != 0) && ((self.video_decoder) != null)) ? plm_video_get_height(self.video_decoder) : 0);
		}
		public static double plm_get_pixel_aspect_ratio(plm_t self)
		{
			return (double)((((plm_init_decoders(self)) != 0) && ((self.video_decoder) != null)) ? plm_video_get_pixel_aspect_ratio(self.video_decoder) : 0);
		}
		public static double plm_get_framerate(plm_t self)
		{
			return (double)((((plm_init_decoders(self)) != 0) && ((self.video_decoder) != null)) ? plm_video_get_framerate(self.video_decoder) : 0);
		}
		public static int plm_get_audio_enabled(plm_t self)
		{
			return (int)(self.audio_enabled);
		}
		public static void plm_set_audio_enabled(plm_t self, int enabled)
		{
			self.audio_enabled = (int)(enabled);
			if (enabled == 0)
			{
				self.audio_packet_type = (int)(0);
				return;
			}

			self.audio_packet_type = (int)((((plm_init_decoders(self)) != 0) && ((self.audio_decoder) != null)) ? PLM_DEMUX_PACKET_AUDIO_1 + self.audio_stream_index : 0);
		}
		public static int plm_get_num_audio_streams(plm_t self)
		{
			return (int)(plm_demux_get_num_audio_streams(self.demux));
		}
		public static void plm_set_audio_stream(plm_t self, int stream_index)
		{
			if (((stream_index) < (0)) || ((stream_index) > (3)))
			{
				return;
			}

			self.audio_stream_index = (int)(stream_index);
			plm_set_audio_enabled(self, (int)(self.audio_enabled));
		}
		public static int plm_get_samplerate(plm_t self)
		{
			return (int)((((plm_init_decoders(self)) != 0) && ((self.audio_decoder) != null)) ? plm_audio_get_samplerate(self.audio_decoder) : 0);
		}
		public static double plm_get_audio_lead_time(plm_t self)
		{
			return (double)(self.audio_lead_time);
		}
		public static void plm_set_audio_lead_time(plm_t self, double lead_time)
		{
			self.audio_lead_time = (double)(lead_time);
		}
		public static double plm_get_time(plm_t self)
		{
			return (double)(self.time);
		}
		public static double plm_get_duration(plm_t self)
		{
			return (double)(plm_demux_get_duration(self.demux, (int)(PLM_DEMUX_PACKET_VIDEO_1)));
		}
		public static void plm_rewind(plm_t self)
		{
			if ((self.video_decoder) != null)
			{
				plm_video_rewind(self.video_decoder);
			}

			if ((self.audio_decoder) != null)
			{
				plm_audio_rewind(self.audio_decoder);
			}

			plm_demux_rewind(self.demux);
			self.time = (double)(0);
			self.has_ended = (int)(0);
		}
		public static int plm_get_loop(plm_t self)
		{
			return (int)(self.loop);
		}
		public static void plm_set_loop(plm_t self, int loop)
		{
			self.loop = (int)(loop);
		}
		public static int plm_has_ended(plm_t self)
		{
			return (int)(self.has_ended);
		}
		public static void plm_set_video_decode_callback(plm_t self, plm_video_decode_callback fp, object user)
		{
			self.video_decode_callback = fp;
			self.video_decode_callback_user_data = user;
		}
		public static void plm_set_audio_decode_callback(plm_t self, plm_audio_decode_callback fp, object user)
		{
			self.audio_decode_callback = fp;
			self.audio_decode_callback_user_data = user;
		}
		public static void plm_decode(plm_t self, double tick)
		{
			if (plm_init_decoders(self) == 0)
			{
				return;
			}

			int decode_video = (int)((((self.video_decode_callback) != null) && ((self.video_packet_type) != 0)) ? 1 : 0);
			int decode_audio = (int)((((self.audio_decode_callback) != null) && ((self.audio_packet_type) != 0)) ? 1 : 0);
			if ((decode_video == 0) && (decode_audio == 0))
			{
				return;
			}

			int did_decode = (int)(0);
			int decode_video_failed = (int)(0);
			int decode_audio_failed = (int)(0);
			double video_target_time = (double)(self.time + tick);
			double audio_target_time = (double)(self.time + tick + self.audio_lead_time);
			do
			{
				did_decode = (int)(0);
				if (((decode_video) != 0) && ((plm_video_get_time(self.video_decoder)) < (video_target_time)))
				{
					plm_frame_t frame = plm_video_decode(self.video_decoder);
					if ((frame) != null)
					{
						self.video_decode_callback(self, frame, self.video_decode_callback_user_data);
						did_decode = (int)(1);
					}
					else
					{
						decode_video_failed = (int)(1);
					}
				}

				if (((decode_audio) != 0) && ((plm_audio_get_time(self.audio_decoder)) < (audio_target_time)))
				{
					plm_samples_t samples = plm_audio_decode(self.audio_decoder);
					if ((samples) != null)
					{
						self.audio_decode_callback(self, samples, self.audio_decode_callback_user_data);
						did_decode = (int)(1);
					}
					else
					{
						decode_audio_failed = (int)(1);
					}
				}
			}
			while ((did_decode) != 0);
			if ((((decode_video == 0) || ((decode_video_failed) != 0)) && ((decode_audio == 0) || ((decode_audio_failed) != 0))) && ((plm_demux_has_ended(self.demux)) != 0))
			{
				plm_handle_end(self);
				return;
			}

			self.time += (double)(tick);
		}
		public static plm_frame_t plm_decode_video(plm_t self)
		{
			if (plm_init_decoders(self) == 0)
			{
				return null;
			}

			if (self.video_packet_type == 0)
			{
				return null;
			}

			plm_frame_t frame = plm_video_decode(self.video_decoder);
			if ((frame) != null)
			{
				self.time = (double)(frame.time);
			}
			else if ((plm_demux_has_ended(self.demux)) != 0)
			{
				plm_handle_end(self);
			}

			return frame;
		}
		public static plm_samples_t plm_decode_audio(plm_t self)
		{
			if (plm_init_decoders(self) == 0)
			{
				return null;
			}

			if (self.audio_packet_type == 0)
			{
				return null;
			}

			plm_samples_t samples = plm_audio_decode(self.audio_decoder);
			if ((samples) != null)
			{
				self.time = (double)(samples.time);
			}
			else if ((plm_demux_has_ended(self.demux)) != 0)
			{
				plm_handle_end(self);
			}

			return samples;
		}
		public static int plm_seek(plm_t self, double time, int seek_exact)
		{
			plm_frame_t frame = plm_seek_frame(self, (double)(time), (int)(seek_exact));
			if (frame == null)
			{
				return (int)(0);
			}

			if ((self.video_decode_callback) != null)
			{
				self.video_decode_callback(self, frame, self.video_decode_callback_user_data);
			}

			if (self.audio_packet_type == 0)
			{
				return (int)(1);
			}

			double start_time = (double)(plm_demux_get_start_time(self.demux, (int)(self.video_packet_type)));
			plm_audio_rewind(self.audio_decoder);
			plm_packet_t packet = null;
			while ((packet = plm_demux_decode(self.demux)) != null)
			{
				if ((packet.type) == (self.video_packet_type))
				{
					plm_buffer_write(self.video_buffer, packet.data, (ulong)(packet.length));
				}
				else if (((packet.type) == (self.audio_packet_type)) && ((packet.pts - start_time) > (self.time)))
				{
					plm_audio_set_time(self.audio_decoder, (double)(packet.pts - start_time));
					plm_buffer_write(self.audio_buffer, packet.data, (ulong)(packet.length));
					plm_decode(self, (double)(0));
					break;
				}
			}

			return (int)(1);
		}
		public static plm_frame_t plm_seek_frame(plm_t self, double time, int seek_exact)
		{
			if (plm_init_decoders(self) == 0)
			{
				return null;
			}

			if (self.video_packet_type == 0)
			{
				return null;
			}

			int type = (int)(self.video_packet_type);
			double start_time = (double)(plm_demux_get_start_time(self.demux, (int)(type)));
			double duration = (double)(plm_demux_get_duration(self.demux, (int)(type)));
			if ((time) < (0))
			{
				time = (double)(0);
			}
			else if ((time) > (duration))
			{
				time = (double)(duration);
			}

			plm_packet_t packet = plm_demux_seek(self.demux, (double)(time), (int)(type), (int)(1));
			if (packet == null)
			{
				return null;
			}

			int previous_audio_packet_type = (int)(self.audio_packet_type);
			self.audio_packet_type = (int)(0);
			plm_video_rewind(self.video_decoder);
			plm_video_set_time(self.video_decoder, (double)(packet.pts - start_time));
			plm_buffer_write(self.video_buffer, packet.data, (ulong)(packet.length));
			plm_frame_t frame = plm_video_decode(self.video_decoder);
			if ((seek_exact) != 0)
			{
				while (((frame) != null) && ((frame.time) < (time)))
				{
					frame = plm_video_decode(self.video_decoder);
				}
			}

			self.audio_packet_type = (int)(previous_audio_packet_type);
			if ((frame) != null)
			{
				self.time = (double)(frame.time);
			}

			self.has_ended = (int)(0);
			return frame;
		}
		public static plm_buffer_t plm_buffer_create_with_callbacks(plm_buffer_load_callback load_callback, plm_buffer_seek_callback seek_callback, plm_buffer_tell_callback tell_callback, ulong length, object user)
		{
			plm_buffer_t self = plm_buffer_create_with_capacity((ulong)(128 * 1024));
			self.mode = plm_buffer_mode.PLM_BUFFER_MODE_FILE;
			self.total_size = (ulong)(length);
			self.load_callback = load_callback;
			self.seek_callback = seek_callback;
			self.tell_callback = tell_callback;
			self.load_callback_user_data = user;
			return self;
		}
		public static plm_buffer_t plm_buffer_create_with_memory(byte* bytes, ulong length, int free_when_done)
		{
			plm_buffer_t self = new plm_buffer_t();

			self.capacity = (ulong)(length);
			self.length = (ulong)(length);
			self.total_size = (ulong)(length);
			self.free_when_done = (int)(free_when_done);
			self.bytes = bytes;
			self.mode = plm_buffer_mode.PLM_BUFFER_MODE_FIXED_MEM;
			self.discard_read_bytes = (int)(0);
			return self;
		}
		public static plm_buffer_t plm_buffer_create_with_capacity(ulong capacity)
		{
			plm_buffer_t self = new plm_buffer_t();

			self.capacity = (ulong)(capacity);
			self.free_when_done = (int)(1);
			self.bytes = (byte*)(CRuntime.malloc((ulong)(capacity)));
			self.mode = plm_buffer_mode.PLM_BUFFER_MODE_RING;
			self.discard_read_bytes = (int)(1);
			return self;
		}
		public static plm_buffer_t plm_buffer_create_for_appending(ulong initial_capacity)
		{
			plm_buffer_t self = plm_buffer_create_with_capacity((ulong)(initial_capacity));
			self.mode = plm_buffer_mode.PLM_BUFFER_MODE_APPEND;
			self.discard_read_bytes = (int)(0);
			return self;
		}
		public static void plm_buffer_destroy(plm_buffer_t self)
		{
			if ((self.free_when_done) != 0)
			{
				CRuntime.free(self.bytes);
			}


		}
		public static ulong plm_buffer_write(plm_buffer_t self, byte* bytes, ulong length)
		{
			if ((self.mode) == plm_buffer_mode.PLM_BUFFER_MODE_FIXED_MEM)
			{
				return (ulong)(0);
			}

			if ((self.discard_read_bytes) != 0)
			{
				plm_buffer_discard_read_bytes(self);
				if ((self.mode) == plm_buffer_mode.PLM_BUFFER_MODE_RING)
				{
					self.total_size = (ulong)(0);
				}
			}

			ulong bytes_available = (ulong)(self.capacity - self.length);
			if ((bytes_available) < (length))
			{
				ulong new_size = (ulong)(self.capacity);
				do
				{
					new_size *= (ulong)(2);
				}
				while ((new_size - self.length) < (length));
				self.bytes = (byte*)(CRuntime.realloc(self.bytes, (ulong)(new_size)));
				self.capacity = (ulong)(new_size);
			}

			CRuntime.memcpy(self.bytes + self.length, bytes, (ulong)(length));
			self.length += (ulong)(length);
			self.has_ended = (int)(0);
			return (ulong)(length);
		}
		public static void plm_buffer_signal_end(plm_buffer_t self)
		{
			self.total_size = (ulong)(self.length);
		}
		public static void plm_buffer_set_load_callback(plm_buffer_t self, plm_buffer_load_callback fp, object user)
		{
			self.load_callback = fp;
			self.load_callback_user_data = user;
		}
		public static void plm_buffer_rewind(plm_buffer_t self)
		{
			plm_buffer_seek(self, (ulong)(0));
		}
		public static ulong plm_buffer_get_size(plm_buffer_t self)
		{
			return (ulong)(((self.mode) == plm_buffer_mode.PLM_BUFFER_MODE_FILE) ? self.total_size : self.length);
		}
		public static ulong plm_buffer_get_remaining(plm_buffer_t self)
		{
			return (ulong)(self.length - (self.bit_index >> 3));
		}
		public static int plm_buffer_has_ended(plm_buffer_t self)
		{
			return (int)(self.has_ended);
		}
		public static plm_demux_t plm_demux_create(plm_buffer_t buffer, int destroy_when_done)
		{
			plm_demux_t self = new plm_demux_t();

			self.buffer = buffer;
			self.destroy_buffer_when_done = (int)(destroy_when_done);
			self.start_time = (double)(-1);
			self.duration = (double)(-1);
			self.start_code = (int)(-1);
			plm_demux_has_headers(self);
			return self;
		}
		public static void plm_demux_destroy(plm_demux_t self)
		{
			if ((self.destroy_buffer_when_done) != 0)
			{
				plm_buffer_destroy(self.buffer);
			}


		}
		public static int plm_demux_has_headers(plm_demux_t self)
		{
			if ((self.has_headers) != 0)
			{
				return (int)(1);
			}

			if (self.has_pack_header == 0)
			{
				if ((self.start_code != PLM_START_PACK) && ((plm_buffer_find_start_code(self.buffer, (int)(PLM_START_PACK))) == (-1)))
				{
					return (int)(0);
				}

				self.start_code = (int)(PLM_START_PACK);
				if (plm_buffer_has(self.buffer, (ulong)(64)) == 0)
				{
					return (int)(0);
				}

				self.start_code = (int)(-1);
				if (plm_buffer_read(self.buffer, (int)(4)) != 0x02)
				{
					return (int)(0);
				}

				self.system_clock_ref = (double)(plm_demux_decode_time(self));
				plm_buffer_skip(self.buffer, (ulong)(1));
				plm_buffer_skip(self.buffer, (ulong)(22));
				plm_buffer_skip(self.buffer, (ulong)(1));
				self.has_pack_header = (int)(1);
			}

			if (self.has_system_header == 0)
			{
				if ((self.start_code != PLM_START_SYSTEM) && ((plm_buffer_find_start_code(self.buffer, (int)(PLM_START_SYSTEM))) == (-1)))
				{
					return (int)(0);
				}

				self.start_code = (int)(PLM_START_SYSTEM);
				if (plm_buffer_has(self.buffer, (ulong)(56)) == 0)
				{
					return (int)(0);
				}

				self.start_code = (int)(-1);
				plm_buffer_skip(self.buffer, (ulong)(16));
				plm_buffer_skip(self.buffer, (ulong)(24));
				self.num_audio_streams = (int)(plm_buffer_read(self.buffer, (int)(6)));
				plm_buffer_skip(self.buffer, (ulong)(5));
				self.num_video_streams = (int)(plm_buffer_read(self.buffer, (int)(5)));
				self.has_system_header = (int)(1);
			}

			self.has_headers = (int)(1);
			return (int)(1);
		}
		public static int plm_demux_probe(plm_demux_t self, ulong probesize)
		{
			int previous_pos = (int)(plm_buffer_tell(self.buffer));
			int video_stream = (int)(0);
			int* audio_streams = stackalloc int[] { 0, 0, 0, 0 };
			do
			{
				self.start_code = (int)(plm_buffer_next_start_code(self.buffer));
				if ((self.start_code) == (PLM_DEMUX_PACKET_VIDEO_1))
				{
					video_stream = (int)(1);
				}
				else if (((self.start_code) >= (PLM_DEMUX_PACKET_AUDIO_1)) && ((self.start_code) <= (PLM_DEMUX_PACKET_AUDIO_4)))
				{
					audio_streams[self.start_code - PLM_DEMUX_PACKET_AUDIO_1] = (int)(1);
				}
			}
			while ((self.start_code != -1) && ((plm_buffer_tell(self.buffer) - (ulong)previous_pos) < (probesize)));
			self.num_video_streams = (int)((video_stream) != 0 ? 1 : 0);
			self.num_audio_streams = (int)(0);
			for (int i = (int)(0); (i) < (4); i++)
			{
				if ((audio_streams[i]) != 0)
				{
					self.num_audio_streams++;
				}
			}

			plm_demux_buffer_seek(self, (ulong)(previous_pos));
			return ((((self.num_video_streams) != 0) || ((self.num_audio_streams) != 0)) ? 1 : 0);
		}
		public static int plm_demux_get_num_video_streams(plm_demux_t self)
		{
			return (int)((plm_demux_has_headers(self)) != 0 ? self.num_video_streams : 0);
		}
		public static int plm_demux_get_num_audio_streams(plm_demux_t self)
		{
			return (int)((plm_demux_has_headers(self)) != 0 ? self.num_audio_streams : 0);
		}
		public static void plm_demux_rewind(plm_demux_t self)
		{
			plm_buffer_rewind(self.buffer);
			self.current_packet.length = (ulong)(0);
			self.next_packet.length = (ulong)(0);
			self.start_code = (int)(-1);
		}
		public static int plm_demux_has_ended(plm_demux_t self)
		{
			return (int)(plm_buffer_has_ended(self.buffer));
		}
		public static plm_packet_t plm_demux_seek(plm_demux_t self, double seek_time, int type, int force_intra)
		{
			if (plm_demux_has_headers(self) == 0)
			{
				return null;
			}

			double duration = (double)(plm_demux_get_duration(self, (int)(type)));
			int file_size = (int)(plm_buffer_get_size(self.buffer));
			int byterate = (int)(file_size / duration);
			double cur_time = (double)(self.last_decoded_pts);
			double scan_span = (double)(1);
			if ((seek_time) > (duration))
			{
				seek_time = (double)(duration);
			}
			else if ((seek_time) < (0))
			{
				seek_time = (double)(0);
			}

			seek_time += (double)(self.start_time);
			for (int retry = (int)(0); (retry) < (32); retry++)
			{
				int found_packet_with_pts = (int)(0);
				int found_packet_in_range = (int)(0);
				int last_valid_packet_start = (int)(-1);
				double first_packet_time = (double)(-1);
				int cur_pos = (int)(plm_buffer_tell(self.buffer));
				int offset = (int)((seek_time - cur_time - scan_span) * byterate);
				int seek_pos = (int)(cur_pos + offset);
				if ((seek_pos) < (0))
				{
					seek_pos = (int)(0);
				}
				else if ((seek_pos) > (file_size - 256))
				{
					seek_pos = (int)(file_size - 256);
				}

				plm_demux_buffer_seek(self, (ulong)(seek_pos));
				while (plm_buffer_find_start_code(self.buffer, (int)(type)) != -1)
				{
					int packet_start = (int)(plm_buffer_tell(self.buffer));
					plm_packet_t packet = plm_demux_decode_packet(self, (int)(type));
					if ((packet == null) || ((packet.pts) == (-1)))
					{
						continue;
					}

					if (((packet.pts) > (seek_time)) || ((packet.pts) < (seek_time - scan_span)))
					{
						found_packet_with_pts = (int)(1);
						byterate = (int)((seek_pos - cur_pos) / (packet.pts - cur_time));
						cur_time = (double)(packet.pts);
						break;
					}

					if (found_packet_in_range == 0)
					{
						found_packet_in_range = (int)(1);
						first_packet_time = (double)(packet.pts);
					}

					if ((force_intra) != 0)
					{
						for (ulong i = (ulong)(0); (i) < (packet.length - 6); i++)
						{
							if (((((packet.data[i]) == (0x00)) && ((packet.data[i + 1]) == (0x00))) && ((packet.data[i + 2]) == (0x01))) && ((packet.data[i + 3]) == (0x00)))
							{
								if ((packet.data[i + 5] & 0x38) == (8))
								{
									last_valid_packet_start = (int)(packet_start);
								}

								break;
							}
						}
					}
					else
					{
						last_valid_packet_start = (int)(packet_start);
					}
				}

				if (last_valid_packet_start != -1)
				{
					plm_demux_buffer_seek(self, (ulong)(last_valid_packet_start));
					return plm_demux_decode_packet(self, (int)(type));
				}
				else if ((found_packet_in_range) != 0)
				{
					scan_span *= (double)(2);
					seek_time = (double)(first_packet_time);
				}
				else if (found_packet_with_pts == 0)
				{
					byterate = (int)((seek_pos - cur_pos) / (duration - cur_time));
					cur_time = (double)(duration);
				}
			}

			return null;
		}
		public static double plm_demux_get_start_time(plm_demux_t self, int type)
		{
			if (self.start_time != -1)
			{
				return (double)(self.start_time);
			}

			int previous_pos = (int)(plm_buffer_tell(self.buffer));
			int previous_start_code = (int)(self.start_code);
			plm_demux_rewind(self);
			do
			{
				plm_packet_t packet = plm_demux_decode(self);
				if (packet == null)
				{
					break;
				}

				if ((packet.type) == (type))
				{
					self.start_time = (double)(packet.pts);
				}
			}
			while ((self.start_time) == (-1));
			plm_demux_buffer_seek(self, (ulong)(previous_pos));
			self.start_code = (int)(previous_start_code);
			return (double)(self.start_time);
		}
		public static double plm_demux_get_duration(plm_demux_t self, int type)
		{
			ulong file_size = (ulong)(plm_buffer_get_size(self.buffer));
			if ((self.duration != -1) && ((self.last_file_size) == (file_size)))
			{
				return (double)(self.duration);
			}

			ulong previous_pos = (ulong)(plm_buffer_tell(self.buffer));
			int previous_start_code = (int)(self.start_code);
			int start_range = (int)(64 * 1024);
			int max_range = (int)(4096 * 1024);
			for (int range = (int)(start_range); (range) <= (max_range); range *= (int)(2))
			{
				int seek_pos = (int)((int)file_size - range);
				if ((seek_pos) < (0))
				{
					seek_pos = (int)(0);
					range = (int)(max_range);
				}

				plm_demux_buffer_seek(self, (ulong)(seek_pos));
				self.current_packet.length = (ulong)(0);
				double last_pts = (double)(-1);
				plm_packet_t packet = null;
				while ((packet = plm_demux_decode(self)) != null)
				{
					if ((packet.pts != -1) && ((packet.type) == (type)))
					{
						last_pts = (double)(packet.pts);
					}
				}

				if (last_pts != -1)
				{
					self.duration = (double)(last_pts - plm_demux_get_start_time(self, (int)(type)));
					break;
				}
			}

			plm_demux_buffer_seek(self, (ulong)(previous_pos));
			self.start_code = (int)(previous_start_code);
			self.last_file_size = (ulong)(file_size);
			return (double)(self.duration);
		}
		public static plm_packet_t plm_demux_decode(plm_demux_t self)
		{
			if (plm_demux_has_headers(self) == 0)
			{
				return null;
			}

			if ((self.current_packet.length) != 0)
			{
				ulong bits_till_next_packet = (ulong)(self.current_packet.length << 3);
				if (plm_buffer_has(self.buffer, (ulong)(bits_till_next_packet)) == 0)
				{
					return null;
				}

				plm_buffer_skip(self.buffer, (ulong)(bits_till_next_packet));
				self.current_packet.length = (ulong)(0);
			}

			if ((self.next_packet.length) != 0)
			{
				return plm_demux_get_packet(self);
			}

			if (self.start_code != -1)
			{
				return plm_demux_decode_packet(self, (int)(self.start_code));
			}

			do
			{
				self.start_code = (int)(plm_buffer_next_start_code(self.buffer));
				if ((((self.start_code) == (PLM_DEMUX_PACKET_VIDEO_1)) || ((self.start_code) == (PLM_DEMUX_PACKET_PRIVATE))) || (((self.start_code) >= (PLM_DEMUX_PACKET_AUDIO_1)) && ((self.start_code) <= (PLM_DEMUX_PACKET_AUDIO_4))))
				{
					return plm_demux_decode_packet(self, (int)(self.start_code));
				}
			}
			while (self.start_code != -1);
			return null;
		}
		public static plm_video_t plm_video_create_with_buffer(plm_buffer_t buffer, int destroy_when_done)
		{
			plm_video_t self = new plm_video_t();

			self.buffer = buffer;
			self.destroy_buffer_when_done = (int)(destroy_when_done);
			self.start_code = (int)(plm_buffer_find_start_code(self.buffer, (int)(PLM_START_SEQUENCE)));
			if (self.start_code != -1)
			{
				plm_video_decode_sequence_header(self);
			}

			return self;
		}
		public static void plm_video_destroy(plm_video_t self)
		{
			if ((self.destroy_buffer_when_done) != 0)
			{
				plm_buffer_destroy(self.buffer);
			}
		}
		public static int plm_video_has_header(plm_video_t self)
		{
			if ((self.has_sequence_header) != 0)
			{
				return (int)(1);
			}

			if (self.start_code != PLM_START_SEQUENCE)
			{
				self.start_code = (int)(plm_buffer_find_start_code(self.buffer, (int)(PLM_START_SEQUENCE)));
			}

			if ((self.start_code) == (-1))
			{
				return (int)(0);
			}

			if (plm_video_decode_sequence_header(self) == 0)
			{
				return (int)(0);
			}

			return (int)(1);
		}
		public static double plm_video_get_framerate(plm_video_t self)
		{
			return (double)((plm_video_has_header(self)) != 0 ? self.framerate : 0);
		}
		public static double plm_video_get_pixel_aspect_ratio(plm_video_t self)
		{
			return (double)((plm_video_has_header(self)) != 0 ? self.pixel_aspect_ratio : 0);
		}
		public static int plm_video_get_width(plm_video_t self)
		{
			return (int)((plm_video_has_header(self)) != 0 ? self.width : 0);
		}
		public static int plm_video_get_height(plm_video_t self)
		{
			return (int)((plm_video_has_header(self)) != 0 ? self.height : 0);
		}
		public static void plm_video_set_no_delay(plm_video_t self, int no_delay)
		{
			self.assume_no_b_frames = (int)(no_delay);
		}
		public static double plm_video_get_time(plm_video_t self)
		{
			return (double)(self.time);
		}
		public static void plm_video_set_time(plm_video_t self, double time)
		{
			self.frames_decoded = (int)(self.framerate * time);
			self.time = (double)(time);
		}
		public static void plm_video_rewind(plm_video_t self)
		{
			plm_buffer_rewind(self.buffer);
			self.time = (double)(0);
			self.frames_decoded = (int)(0);
			self.has_reference_frame = (int)(0);
			self.start_code = (int)(-1);
		}
		public static int plm_video_has_ended(plm_video_t self)
		{
			return (int)(plm_buffer_has_ended(self.buffer));
		}
		public static plm_frame_t plm_video_decode(plm_video_t self)
		{
			if (plm_video_has_header(self) == 0)
			{
				return null;
			}

			plm_frame_t frame = null;
			do
			{
				if (self.start_code != PLM_START_PICTURE)
				{
					self.start_code = (int)(plm_buffer_find_start_code(self.buffer, (int)(PLM_START_PICTURE)));
					if ((self.start_code) == (-1))
					{
						if (((((self.has_reference_frame) != 0) && (self.assume_no_b_frames == 0)) && ((plm_buffer_has_ended(self.buffer)) != 0)) && (((self.picture_type) == (PLM_VIDEO_PICTURE_TYPE_INTRA)) || ((self.picture_type) == (PLM_VIDEO_PICTURE_TYPE_PREDICTIVE))))
						{
							self.has_reference_frame = (int)(0);
							frame = self.frame_backward;
							break;
						}

						return null;
					}
				}

				if (((plm_buffer_has_start_code(self.buffer, (int)(PLM_START_PICTURE))) == (-1)) && (plm_buffer_has_ended(self.buffer) == 0))
				{
					return null;
				}

				plm_buffer_discard_read_bytes(self.buffer);
				plm_video_decode_picture(self);
				if ((self.assume_no_b_frames) != 0)
				{
					frame = self.frame_backward;
				}
				else if ((self.picture_type) == (PLM_VIDEO_PICTURE_TYPE_B))
				{
					frame = self.frame_current;
				}
				else if ((self.has_reference_frame) != 0)
				{
					frame = self.frame_forward;
				}
				else
				{
					self.has_reference_frame = (int)(1);
				}
			}
			while (frame == null);
			frame.time = (double)(self.time);
			self.frames_decoded++;
			self.time = (double)((double)(self.frames_decoded) / self.framerate);
			return frame;
		}
		public static void plm_frame_to_rgb(plm_frame_t frame, byte* dest, int stride)
		{
			int cols = (int)(frame.width >> 1);
			int rows = (int)(frame.height >> 1);
			int yw = (int)(frame.y.width);
			int cw = (int)(frame.cb.width);
			for (int row = (int)(0); (row) < (rows); row++)
			{
				int c_index = (int)(row * cw);
				int y_index = (int)(row * 2 * yw);
				int d_index = (int)(row * 2 * stride);
				for (int col = (int)(0); (col) < (cols); col++)
				{
					int y = 0;
					int cr = (int)(frame.cr.data[c_index] - 128);
					int cb = (int)(frame.cb.data[c_index] - 128);
					int r = (int)((cr * 104597) >> 16);
					int g = (int)((cb * 25674 + cr * 53278) >> 16);
					int b = (int)((cb * 132201) >> 16);
					y = (int)(((frame.y.data[y_index + 0] - 16) * 76309) >> 16);
					dest[d_index + 0 + 0] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + 0 + 1] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + 0 + 2] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + 1] - 16) * 76309) >> 16);
					dest[d_index + 3 + 0] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + 3 + 1] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + 3 + 2] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + yw] - 16) * 76309) >> 16);
					dest[d_index + stride + 0] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + stride + 1] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + stride + 2] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + yw + 1] - 16) * 76309) >> 16);
					dest[d_index + stride + 3 + 0] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + stride + 3 + 1] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + stride + 3 + 2] = (byte)(plm_clamp((int)(y + b)));
					c_index += (int)(1);
					y_index += (int)(2);
					d_index += (int)(2 * 3);
				}
			}
		}
		public static void plm_frame_to_bgr(plm_frame_t frame, byte* dest, int stride)
		{
			int cols = (int)(frame.width >> 1);
			int rows = (int)(frame.height >> 1);
			int yw = (int)(frame.y.width);
			int cw = (int)(frame.cb.width);
			for (int row = (int)(0); (row) < (rows); row++)
			{
				int c_index = (int)(row * cw);
				int y_index = (int)(row * 2 * yw);
				int d_index = (int)(row * 2 * stride);
				for (int col = (int)(0); (col) < (cols); col++)
				{
					int y = 0;
					int cr = (int)(frame.cr.data[c_index] - 128);
					int cb = (int)(frame.cb.data[c_index] - 128);
					int r = (int)((cr * 104597) >> 16);
					int g = (int)((cb * 25674 + cr * 53278) >> 16);
					int b = (int)((cb * 132201) >> 16);
					y = (int)(((frame.y.data[y_index + 0] - 16) * 76309) >> 16);
					dest[d_index + 0 + 2] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + 0 + 1] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + 0 + 0] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + 1] - 16) * 76309) >> 16);
					dest[d_index + 3 + 2] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + 3 + 1] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + 3 + 0] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + yw] - 16) * 76309) >> 16);
					dest[d_index + stride + 2] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + stride + 1] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + stride + 0] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + yw + 1] - 16) * 76309) >> 16);
					dest[d_index + stride + 3 + 2] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + stride + 3 + 1] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + stride + 3 + 0] = (byte)(plm_clamp((int)(y + b)));
					c_index += (int)(1);
					y_index += (int)(2);
					d_index += (int)(2 * 3);
				}
			}
		}
		public static void plm_frame_to_rgba(plm_frame_t frame, byte* dest, int stride)
		{
			int cols = (int)(frame.width >> 1);
			int rows = (int)(frame.height >> 1);
			int yw = (int)(frame.y.width);
			int cw = (int)(frame.cb.width);
			for (int row = (int)(0); (row) < (rows); row++)
			{
				int c_index = (int)(row * cw);
				int y_index = (int)(row * 2 * yw);
				int d_index = (int)(row * 2 * stride);
				for (int col = (int)(0); (col) < (cols); col++)
				{
					int y = 0;
					int cr = (int)(frame.cr.data[c_index] - 128);
					int cb = (int)(frame.cb.data[c_index] - 128);
					int r = (int)((cr * 104597) >> 16);
					int g = (int)((cb * 25674 + cr * 53278) >> 16);
					int b = (int)((cb * 132201) >> 16);
					y = (int)(((frame.y.data[y_index + 0] - 16) * 76309) >> 16);
					dest[d_index + 0 + 0] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + 0 + 1] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + 0 + 2] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + 1] - 16) * 76309) >> 16);
					dest[d_index + 4 + 0] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + 4 + 1] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + 4 + 2] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + yw] - 16) * 76309) >> 16);
					dest[d_index + stride + 0] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + stride + 1] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + stride + 2] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + yw + 1] - 16) * 76309) >> 16);
					dest[d_index + stride + 4 + 0] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + stride + 4 + 1] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + stride + 4 + 2] = (byte)(plm_clamp((int)(y + b)));
					c_index += (int)(1);
					y_index += (int)(2);
					d_index += (int)(2 * 4);
				}
			}
		}
		public static void plm_frame_to_bgra(plm_frame_t frame, byte* dest, int stride)
		{
			int cols = (int)(frame.width >> 1);
			int rows = (int)(frame.height >> 1);
			int yw = (int)(frame.y.width);
			int cw = (int)(frame.cb.width);
			for (int row = (int)(0); (row) < (rows); row++)
			{
				int c_index = (int)(row * cw);
				int y_index = (int)(row * 2 * yw);
				int d_index = (int)(row * 2 * stride);
				for (int col = (int)(0); (col) < (cols); col++)
				{
					int y = 0;
					int cr = (int)(frame.cr.data[c_index] - 128);
					int cb = (int)(frame.cb.data[c_index] - 128);
					int r = (int)((cr * 104597) >> 16);
					int g = (int)((cb * 25674 + cr * 53278) >> 16);
					int b = (int)((cb * 132201) >> 16);
					y = (int)(((frame.y.data[y_index + 0] - 16) * 76309) >> 16);
					dest[d_index + 0 + 2] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + 0 + 1] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + 0 + 0] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + 1] - 16) * 76309) >> 16);
					dest[d_index + 4 + 2] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + 4 + 1] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + 4 + 0] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + yw] - 16) * 76309) >> 16);
					dest[d_index + stride + 2] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + stride + 1] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + stride + 0] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + yw + 1] - 16) * 76309) >> 16);
					dest[d_index + stride + 4 + 2] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + stride + 4 + 1] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + stride + 4 + 0] = (byte)(plm_clamp((int)(y + b)));
					c_index += (int)(1);
					y_index += (int)(2);
					d_index += (int)(2 * 4);
				}
			}
		}
		public static void plm_frame_to_argb(plm_frame_t frame, byte* dest, int stride)
		{
			int cols = (int)(frame.width >> 1);
			int rows = (int)(frame.height >> 1);
			int yw = (int)(frame.y.width);
			int cw = (int)(frame.cb.width);
			for (int row = (int)(0); (row) < (rows); row++)
			{
				int c_index = (int)(row * cw);
				int y_index = (int)(row * 2 * yw);
				int d_index = (int)(row * 2 * stride);
				for (int col = (int)(0); (col) < (cols); col++)
				{
					int y = 0;
					int cr = (int)(frame.cr.data[c_index] - 128);
					int cb = (int)(frame.cb.data[c_index] - 128);
					int r = (int)((cr * 104597) >> 16);
					int g = (int)((cb * 25674 + cr * 53278) >> 16);
					int b = (int)((cb * 132201) >> 16);
					y = (int)(((frame.y.data[y_index + 0] - 16) * 76309) >> 16);
					dest[d_index + 0 + 1] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + 0 + 2] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + 0 + 3] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + 1] - 16) * 76309) >> 16);
					dest[d_index + 4 + 1] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + 4 + 2] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + 4 + 3] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + yw] - 16) * 76309) >> 16);
					dest[d_index + stride + 1] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + stride + 2] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + stride + 3] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + yw + 1] - 16) * 76309) >> 16);
					dest[d_index + stride + 4 + 1] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + stride + 4 + 2] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + stride + 4 + 3] = (byte)(plm_clamp((int)(y + b)));
					c_index += (int)(1);
					y_index += (int)(2);
					d_index += (int)(2 * 4);
				}
			}
		}
		public static void plm_frame_to_abgr(plm_frame_t frame, byte* dest, int stride)
		{
			int cols = (int)(frame.width >> 1);
			int rows = (int)(frame.height >> 1);
			int yw = (int)(frame.y.width);
			int cw = (int)(frame.cb.width);
			for (int row = (int)(0); (row) < (rows); row++)
			{
				int c_index = (int)(row * cw);
				int y_index = (int)(row * 2 * yw);
				int d_index = (int)(row * 2 * stride);
				for (int col = (int)(0); (col) < (cols); col++)
				{
					int y = 0;
					int cr = (int)(frame.cr.data[c_index] - 128);
					int cb = (int)(frame.cb.data[c_index] - 128);
					int r = (int)((cr * 104597) >> 16);
					int g = (int)((cb * 25674 + cr * 53278) >> 16);
					int b = (int)((cb * 132201) >> 16);
					y = (int)(((frame.y.data[y_index + 0] - 16) * 76309) >> 16);
					dest[d_index + 0 + 3] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + 0 + 2] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + 0 + 1] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + 1] - 16) * 76309) >> 16);
					dest[d_index + 4 + 3] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + 4 + 2] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + 4 + 1] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + yw] - 16) * 76309) >> 16);
					dest[d_index + stride + 3] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + stride + 2] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + stride + 1] = (byte)(plm_clamp((int)(y + b)));
					y = (int)(((frame.y.data[y_index + yw + 1] - 16) * 76309) >> 16);
					dest[d_index + stride + 4 + 3] = (byte)(plm_clamp((int)(y + r)));
					dest[d_index + stride + 4 + 2] = (byte)(plm_clamp((int)(y - g)));
					dest[d_index + stride + 4 + 1] = (byte)(plm_clamp((int)(y + b)));
					c_index += (int)(1);
					y_index += (int)(2);
					d_index += (int)(2 * 4);
				}
			}
		}
		public static plm_audio_t plm_audio_create_with_buffer(plm_buffer_t buffer, int destroy_when_done)
		{
			plm_audio_t self = new plm_audio_t();

			self.samples.count = (uint)(1152);
			self.buffer = buffer;
			self.destroy_buffer_when_done = (int)(destroy_when_done);
			self.samplerate_index = (int)(3);
			Array.Copy(PLM_AUDIO_SYNTHESIS_WINDOW, self.D, 512);
			Array.Copy(PLM_AUDIO_SYNTHESIS_WINDOW, 0, self.D, 512, 512);
			self.next_frame_data_size = (int)(plm_audio_decode_header(self));
			return self;
		}
		public static void plm_audio_destroy(plm_audio_t self)
		{
			if ((self.destroy_buffer_when_done) != 0)
			{
				plm_buffer_destroy(self.buffer);
			}


		}
		public static int plm_audio_has_header(plm_audio_t self)
		{
			if ((self.has_header) != 0)
			{
				return (int)(1);
			}

			self.next_frame_data_size = (int)(plm_audio_decode_header(self));
			return (int)(self.has_header);
		}
		public static int plm_audio_get_samplerate(plm_audio_t self)
		{
			return (int)((plm_audio_has_header(self)) != 0 ? PLM_AUDIO_SAMPLE_RATE[self.samplerate_index] : 0);
		}
		public static double plm_audio_get_time(plm_audio_t self)
		{
			return (double)(self.time);
		}
		public static void plm_audio_set_time(plm_audio_t self, double time)
		{
			self.samples_decoded = (int)(time * (double)(PLM_AUDIO_SAMPLE_RATE[self.samplerate_index]));
			self.time = (double)(time);
		}
		public static void plm_audio_rewind(plm_audio_t self)
		{
			plm_buffer_rewind(self.buffer);
			self.time = (double)(0);
			self.samples_decoded = (int)(0);
			self.next_frame_data_size = (int)(0);
		}
		public static int plm_audio_has_ended(plm_audio_t self)
		{
			return (int)(plm_buffer_has_ended(self.buffer));
		}
		public static plm_samples_t plm_audio_decode(plm_audio_t self)
		{
			if (self.next_frame_data_size == 0)
			{
				if (plm_buffer_has(self.buffer, (ulong)(48)) == 0)
				{
					return null;
				}

				self.next_frame_data_size = (int)(plm_audio_decode_header(self));
			}

			if (((self.next_frame_data_size) == (0)) || (plm_buffer_has(self.buffer, (ulong)(self.next_frame_data_size << 3)) == 0))
			{
				return null;
			}

			plm_audio_decode_frame(self);
			self.next_frame_data_size = (int)(0);
			self.samples.time = (double)(self.time);
			self.samples_decoded += (int)(1152);
			self.time = (double)((double)(self.samples_decoded) / (double)(PLM_AUDIO_SAMPLE_RATE[self.samplerate_index]));
			return self.samples;
		}
		public static int plm_init_decoders(plm_t self)
		{
			if ((self.has_decoders) != 0)
			{
				return (int)(1);
			}

			if (plm_demux_has_headers(self.demux) == 0)
			{
				return (int)(0);
			}

			if ((plm_demux_get_num_video_streams(self.demux)) > (0))
			{
				if ((self.video_enabled) != 0)
				{
					self.video_packet_type = (int)(PLM_DEMUX_PACKET_VIDEO_1);
				}

				if (self.video_decoder == null)
				{
					self.video_buffer = plm_buffer_create_with_capacity((ulong)(128 * 1024));
					plm_buffer_set_load_callback(self.video_buffer, plm_read_video_packet, self);
					self.video_decoder = plm_video_create_with_buffer(self.video_buffer, (int)(1));
				}
			}

			if ((plm_demux_get_num_audio_streams(self.demux)) > (0))
			{
				if ((self.audio_enabled) != 0)
				{
					self.audio_packet_type = (int)(PLM_DEMUX_PACKET_AUDIO_1 + self.audio_stream_index);
				}

				if (self.audio_decoder == null)
				{
					self.audio_buffer = plm_buffer_create_with_capacity((ulong)(128 * 1024));
					plm_buffer_set_load_callback(self.audio_buffer, plm_read_audio_packet, self);
					self.audio_decoder = plm_audio_create_with_buffer(self.audio_buffer, (int)(1));
				}
			}

			self.has_decoders = (int)(1);
			return (int)(1);
		}
		public static void plm_handle_end(plm_t self)
		{
			if ((self.loop) != 0)
			{
				plm_rewind(self);
			}
			else
			{
				self.has_ended = (int)(1);
			}
		}
		public static void plm_read_video_packet(plm_buffer_t buffer, object user)
		{
			plm_t self = (plm_t)(user);
			plm_read_packets(self, (int)(self.video_packet_type));
		}
		public static void plm_read_audio_packet(plm_buffer_t buffer, object user)
		{
			plm_t self = (plm_t)(user);
			plm_read_packets(self, (int)(self.audio_packet_type));
		}
		public static void plm_read_packets(plm_t self, int requested_type)
		{
			plm_packet_t packet;
			while ((packet = plm_demux_decode(self.demux)) != null)
			{
				if ((packet.type) == (self.video_packet_type))
				{
					plm_buffer_write(self.video_buffer, packet.data, (ulong)(packet.length));
				}
				else if ((packet.type) == (self.audio_packet_type))
				{
					plm_buffer_write(self.audio_buffer, packet.data, (ulong)(packet.length));
				}

				if ((packet.type) == (requested_type))
				{
					return;
				}
			}

			if ((plm_demux_has_ended(self.demux)) != 0)
			{
				if ((self.video_buffer) != null)
				{
					plm_buffer_signal_end(self.video_buffer);
				}

				if ((self.audio_buffer) != null)
				{
					plm_buffer_signal_end(self.audio_buffer);
				}
			}
		}
		public static void plm_buffer_seek(plm_buffer_t self, ulong pos)
		{
			self.has_ended = (int)(0);
			if ((self.seek_callback) != null)
			{
				self.seek_callback(self, (ulong)(pos), self.load_callback_user_data);
				self.bit_index = (ulong)(0);
				self.length = (ulong)(0);
			}
			else if ((self.mode) == plm_buffer_mode.PLM_BUFFER_MODE_RING)
			{
				if (pos != 0)
				{
					return;
				}

				self.bit_index = (ulong)(0);
				self.length = (ulong)(0);
				self.total_size = (ulong)(0);
			}
			else if ((pos) < (self.length))
			{
				self.bit_index = (ulong)(pos << 3);
			}
		}
		public static void plm_buffer_discard_read_bytes(plm_buffer_t self)
		{
			ulong byte_pos = (ulong)(self.bit_index >> 3);
			if ((byte_pos) == (self.length))
			{
				self.bit_index = (ulong)(0);
				self.length = (ulong)(0);
			}
			else if ((byte_pos) > (0))
			{
				CRuntime.memmove(self.bytes, self.bytes + byte_pos, (ulong)(self.length - byte_pos));
				self.bit_index -= (ulong)(byte_pos << 3);
				self.length -= (ulong)(byte_pos);
			}
		}
		public static int plm_buffer_has(plm_buffer_t self, ulong count)
		{
			if (((self.length << 3) - self.bit_index) >= (count))
			{
				return (int)(1);
			}

			if ((self.load_callback) != null)
			{
				self.load_callback(self, self.load_callback_user_data);
				if (((self.length << 3) - self.bit_index) >= (count))
				{
					return (int)(1);
				}
			}

			if ((self.total_size != 0) && ((self.length) == (self.total_size)))
			{
				self.has_ended = (int)(1);
			}

			return (int)(0);
		}
		public static int plm_buffer_read(plm_buffer_t self, int count)
		{
			if (plm_buffer_has(self, (ulong)(count)) == 0)
			{
				return (int)(0);
			}

			int value = (int)(0);
			while ((count) != 0)
			{
				int current_byte = (int)(self.bytes[self.bit_index >> 3]);
				int remaining = (int)(8 - (self.bit_index & 7));
				int read = (int)((remaining) < (count) ? remaining : count);
				int shift = (int)(remaining - read);
				int mask = (int)(0xff >> (8 - read));
				value = (int)((value << read) | ((current_byte & (mask << shift)) >> shift));
				self.bit_index += (ulong)(read);
				count -= (int)(read);
			}

			return (int)(value);
		}
		public static void plm_buffer_align(plm_buffer_t self)
		{
			self.bit_index = (ulong)(((self.bit_index + 7) >> 3) << 3);
		}
		public static void plm_buffer_skip(plm_buffer_t self, ulong count)
		{
			if ((plm_buffer_has(self, (ulong)(count))) != 0)
			{
				self.bit_index += (ulong)(count);
			}
		}
		public static int plm_buffer_skip_bytes(plm_buffer_t self, byte v)
		{
			plm_buffer_align(self);
			int skipped = (int)(0);
			while (((plm_buffer_has(self, (ulong)(8))) != 0) && ((self.bytes[self.bit_index >> 3]) == (v)))
			{
				self.bit_index += (ulong)(8);
				skipped++;
			}

			return (int)(skipped);
		}
		public static int plm_buffer_next_start_code(plm_buffer_t self)
		{
			plm_buffer_align(self);
			while ((plm_buffer_has(self, (ulong)(5 << 3))) != 0)
			{
				ulong byte_index = (ulong)((self.bit_index) >> 3);
				if ((((self.bytes[byte_index]) == (0x00)) && ((self.bytes[byte_index + 1]) == (0x00))) && ((self.bytes[byte_index + 2]) == (0x01)))
				{
					self.bit_index = (ulong)((byte_index + 4) << 3);
					return (int)(self.bytes[byte_index + 3]);
				}

				self.bit_index += (ulong)(8);
			}

			return (int)(-1);
		}
		public static int plm_buffer_find_start_code(plm_buffer_t self, int code)
		{
			int current = (int)(0);
			while (true)
			{
				current = (int)(plm_buffer_next_start_code(self));
				if (((current) == (code)) || ((current) == (-1)))
				{
					return (int)(current);
				}
			}
		}
		public static short plm_buffer_read_vlc(plm_buffer_t self, plm_vlc_t* table)
		{
			plm_vlc_t state = new plm_vlc_t();
			do
			{
				state = (plm_vlc_t)(table[state.index + plm_buffer_read(self, (int)(1))]);
			}
			while ((state.index) > (0));
			return (short)(state.value);
		}
		public static int plm_buffer_has_start_code(plm_buffer_t self, int code)
		{
			ulong previous_bit_index = (ulong)(self.bit_index);
			int previous_discard_read_bytes = (int)(self.discard_read_bytes);
			self.discard_read_bytes = (int)(0);
			int current = (int)(plm_buffer_find_start_code(self, (int)(code)));
			self.bit_index = (ulong)(previous_bit_index);
			self.discard_read_bytes = (int)(previous_discard_read_bytes);
			return (int)(current);
		}
		public static int plm_buffer_peek_non_zero(plm_buffer_t self, int bit_count)
		{
			if (plm_buffer_has(self, (ulong)(bit_count)) == 0)
			{
				return (int)(0);
			}

			int val = (int)(plm_buffer_read(self, (int)(bit_count)));
			self.bit_index -= (ulong)(bit_count);
			return (int)(val != 0 ? 1 : 0);
		}
		public static void plm_demux_buffer_seek(plm_demux_t self, ulong pos)
		{
			plm_buffer_seek(self.buffer, (ulong)(pos));
			self.current_packet.length = (ulong)(0);
			self.next_packet.length = (ulong)(0);
			self.start_code = (int)(-1);
		}
		public static double plm_demux_decode_time(plm_demux_t self)
		{
			long clock = (long)(plm_buffer_read(self.buffer, (int)(3)) << 30);
			plm_buffer_skip(self.buffer, (ulong)(1));
			clock |= (long)(plm_buffer_read(self.buffer, (int)(15)) << 15);
			plm_buffer_skip(self.buffer, (ulong)(1));
			clock |= (long)(plm_buffer_read(self.buffer, (int)(15)));
			plm_buffer_skip(self.buffer, (ulong)(1));
			return (double)((double)(clock) / 90000.0);
		}
		public static plm_packet_t plm_demux_decode_packet(plm_demux_t self, int type)
		{
			if (plm_buffer_has(self.buffer, (ulong)(16 << 3)) == 0)
			{
				return null;
			}

			self.start_code = (int)(-1);
			self.next_packet.type = (int)(type);
			self.next_packet.length = (ulong)(plm_buffer_read(self.buffer, (int)(16)));
			self.next_packet.length -= (ulong)(plm_buffer_skip_bytes(self.buffer, (byte)(0xff)));
			if ((plm_buffer_read(self.buffer, (int)(2))) == (0x01))
			{
				plm_buffer_skip(self.buffer, (ulong)(16));
				self.next_packet.length -= (ulong)(2);
			}

			int pts_dts_marker = (int)(plm_buffer_read(self.buffer, (int)(2)));
			if ((pts_dts_marker) == (0x03))
			{
				self.next_packet.pts = (double)(plm_demux_decode_time(self));
				self.last_decoded_pts = (double)(self.next_packet.pts);
				plm_buffer_skip(self.buffer, (ulong)(40));
				self.next_packet.length -= (ulong)(10);
			}
			else if ((pts_dts_marker) == (0x02))
			{
				self.next_packet.pts = (double)(plm_demux_decode_time(self));
				self.last_decoded_pts = (double)(self.next_packet.pts);
				self.next_packet.length -= (ulong)(5);
			}
			else if ((pts_dts_marker) == (0x00))
			{
				self.next_packet.pts = (double)(-1);
				plm_buffer_skip(self.buffer, (ulong)(4));
				self.next_packet.length -= (ulong)(1);
			}
			else
			{
				return null;
			}

			return plm_demux_get_packet(self);
		}
		public static plm_packet_t plm_demux_get_packet(plm_demux_t self)
		{
			if (plm_buffer_has(self.buffer, (ulong)(self.next_packet.length << 3)) == 0)
			{
				return null;
			}

			self.current_packet.data = self.buffer.bytes + (self.buffer.bit_index >> 3);
			self.current_packet.length = (ulong)(self.next_packet.length);
			self.current_packet.type = (int)(self.next_packet.type);
			self.current_packet.pts = (double)(self.next_packet.pts);
			self.next_packet.length = (ulong)(0);
			return self.current_packet;
		}
		public static byte plm_clamp(int n)
		{
			if ((n) > (255))
			{
				n = (int)(255);
			}
			else if ((n) < (0))
			{
				n = (int)(0);
			}

			return (byte)(n);
		}
		public static int plm_video_decode_sequence_header(plm_video_t self)
		{
			int max_header_size = (int)(64 + 2 * 64 * 8);
			if (plm_buffer_has(self.buffer, (ulong)(max_header_size)) == 0)
			{
				return (int)(0);
			}

			self.width = (int)(plm_buffer_read(self.buffer, (int)(12)));
			self.height = (int)(plm_buffer_read(self.buffer, (int)(12)));
			if (((self.width) <= (0)) || ((self.height) <= (0)))
			{
				return (int)(0);
			}

			int pixel_aspect_ratio_code = 0;
			pixel_aspect_ratio_code = (int)(plm_buffer_read(self.buffer, (int)(4)));
			pixel_aspect_ratio_code -= (int)(1);
			if ((pixel_aspect_ratio_code) < (0))
			{
				pixel_aspect_ratio_code = (int)(0);
			}

			int par_last = (int)(14 * sizeof(float) / sizeof(float) - 1);
			if ((pixel_aspect_ratio_code) > (par_last))
			{
				pixel_aspect_ratio_code = (int)(par_last);
			}

			self.pixel_aspect_ratio = (double)(PLM_VIDEO_PIXEL_ASPECT_RATIO[pixel_aspect_ratio_code]);
			self.framerate = (double)(PLM_VIDEO_PICTURE_RATE[plm_buffer_read(self.buffer, (int)(4))]);
			plm_buffer_skip(self.buffer, (ulong)(18 + 1 + 10 + 1));
			if ((plm_buffer_read(self.buffer, (int)(1))) != 0)
			{
				for (int i = (int)(0); (i) < (64); i++)
				{
					int idx = (int)(PLM_VIDEO_ZIG_ZAG[i]);
					self.intra_quant_matrix[idx] = (byte)(plm_buffer_read(self.buffer, (int)(8)));
				}
			}
			else
			{
				Array.Copy(PLM_VIDEO_INTRA_QUANT_MATRIX, self.intra_quant_matrix, 64);
			}

			if ((plm_buffer_read(self.buffer, (int)(1))) != 0)
			{
				for (int i = (int)(0); (i) < (64); i++)
				{
					int idx = (int)(PLM_VIDEO_ZIG_ZAG[i]);
					self.non_intra_quant_matrix[idx] = (byte)(plm_buffer_read(self.buffer, (int)(8)));
				}
			}
			else
			{
				Array.Copy(PLM_VIDEO_NON_INTRA_QUANT_MATRIX, self.non_intra_quant_matrix, 64);
			}

			self.mb_width = (int)((self.width + 15) >> 4);
			self.mb_height = (int)((self.height + 15) >> 4);
			self.mb_size = (int)(self.mb_width * self.mb_height);
			self.luma_width = (int)(self.mb_width << 4);
			self.luma_height = (int)(self.mb_height << 4);
			self.chroma_width = (int)(self.mb_width << 3);
			self.chroma_height = (int)(self.mb_height << 3);
			plm_video_init_frame(self, self.frame_current);
			plm_video_init_frame(self, self.frame_forward);
			plm_video_init_frame(self, self.frame_backward);
			self.has_sequence_header = (int)(1);
			return (int)(1);
		}
		public static void plm_video_init_frame(plm_video_t self, plm_frame_t frame)
		{
			ulong luma_plane_size = (ulong)(self.luma_width * self.luma_height);
			ulong chroma_plane_size = (ulong)(self.chroma_width * self.chroma_height);
			frame.width = (uint)(self.width);
			frame.height = (uint)(self.height);
			frame.y.width = (uint)(self.luma_width);
			frame.y.height = (uint)(self.luma_height);
			frame.y.data = new byte[luma_plane_size];
			frame.cr.width = (uint)(self.chroma_width);
			frame.cr.height = (uint)(self.chroma_height);
			frame.cr.data = new byte[chroma_plane_size];
			frame.cb.width = (uint)(self.chroma_width);
			frame.cb.height = (uint)(self.chroma_height);
			frame.cb.data = new byte[chroma_plane_size];
		}
		public static void plm_video_decode_picture(plm_video_t self)
		{
			plm_buffer_skip(self.buffer, (ulong)(10));
			self.picture_type = (int)(plm_buffer_read(self.buffer, (int)(3)));
			plm_buffer_skip(self.buffer, (ulong)(16));
			if (((self.picture_type) <= (0)) || ((self.picture_type) > (PLM_VIDEO_PICTURE_TYPE_B)))
			{
				return;
			}

			if (((self.picture_type) == (PLM_VIDEO_PICTURE_TYPE_PREDICTIVE)) || ((self.picture_type) == (PLM_VIDEO_PICTURE_TYPE_B)))
			{
				self.motion_forward.full_px = (int)(plm_buffer_read(self.buffer, (int)(1)));
				int f_code = (int)(plm_buffer_read(self.buffer, (int)(3)));
				if ((f_code) == (0))
				{
					return;
				}

				self.motion_forward.r_size = (int)(f_code - 1);
			}

			if ((self.picture_type) == (PLM_VIDEO_PICTURE_TYPE_B))
			{
				self.motion_backward.full_px = (int)(plm_buffer_read(self.buffer, (int)(1)));
				int f_code = (int)(plm_buffer_read(self.buffer, (int)(3)));
				if ((f_code) == (0))
				{
					return;
				}

				self.motion_backward.r_size = (int)(f_code - 1);
			}

			plm_frame_t frame_temp = (plm_frame_t)(self.frame_forward);
			if (((self.picture_type) == (PLM_VIDEO_PICTURE_TYPE_INTRA)) || ((self.picture_type) == (PLM_VIDEO_PICTURE_TYPE_PREDICTIVE)))
			{
				self.frame_forward = self.frame_backward.Clone();
			}

			do
			{
				self.start_code = (int)(plm_buffer_next_start_code(self.buffer));
			}
			while (((self.start_code) == (PLM_START_EXTENSION)) || ((self.start_code) == (PLM_START_USER_DATA)));
			while ((((self.start_code) >= (PLM_START_SLICE_FIRST)) && ((self.start_code) <= (PLM_START_SLICE_LAST))))
			{
				plm_video_decode_slice(self, (int)(self.start_code & 0x000000FF));
				if ((self.macroblock_address) >= (self.mb_size - 2))
				{
					break;
				}

				self.start_code = (int)(plm_buffer_next_start_code(self.buffer));
			}

			if (((self.picture_type) == (PLM_VIDEO_PICTURE_TYPE_INTRA)) || ((self.picture_type) == (PLM_VIDEO_PICTURE_TYPE_PREDICTIVE)))
			{
				self.frame_backward = self.frame_current.Clone();
				self.frame_current = frame_temp.Clone();
			}
		}
		public static void plm_video_decode_slice(plm_video_t self, int slice)
		{
			self.slice_begin = (int)(1);
			self.macroblock_address = (int)((slice - 1) * self.mb_width - 1);
			self.motion_backward.h = (int)(self.motion_forward.h = (int)(0));
			self.motion_backward.v = (int)(self.motion_forward.v = (int)(0));
			self.dc_predictor[0] = (int)(128);
			self.dc_predictor[1] = (int)(128);
			self.dc_predictor[2] = (int)(128);
			self.quantizer_scale = (int)(plm_buffer_read(self.buffer, (int)(5)));
			while ((plm_buffer_read(self.buffer, (int)(1))) != 0)
			{
				plm_buffer_skip(self.buffer, (ulong)(8));
			}

			do
			{
				plm_video_decode_macroblock(self);
			}
			while (((self.macroblock_address) < (self.mb_size - 1)) && ((plm_buffer_peek_non_zero(self.buffer, (int)(23))) != 0));
		}
		public static void plm_video_decode_macroblock(plm_video_t self)
		{
			int increment = (int)(0);
			int t = (int)(plm_buffer_read_vlc(self.buffer, PLM_VIDEO_MACROBLOCK_ADDRESS_INCREMENT));
			while ((t) == (34))
			{
				t = (int)(plm_buffer_read_vlc(self.buffer, PLM_VIDEO_MACROBLOCK_ADDRESS_INCREMENT));
			}

			while ((t) == (35))
			{
				increment += (int)(33);
				t = (int)(plm_buffer_read_vlc(self.buffer, PLM_VIDEO_MACROBLOCK_ADDRESS_INCREMENT));
			}

			increment += (int)(t);
			if ((self.slice_begin) != 0)
			{
				self.slice_begin = (int)(0);
				self.macroblock_address += (int)(increment);
			}
			else
			{
				if ((self.macroblock_address + increment) >= (self.mb_size))
				{
					return;
				}

				if ((increment) > (1))
				{
					self.dc_predictor[0] = (int)(128);
					self.dc_predictor[1] = (int)(128);
					self.dc_predictor[2] = (int)(128);
					if ((self.picture_type) == (PLM_VIDEO_PICTURE_TYPE_PREDICTIVE))
					{
						self.motion_forward.h = (int)(0);
						self.motion_forward.v = (int)(0);
					}
				}

				while ((increment) > (1))
				{
					self.macroblock_address++;
					self.mb_row = (int)(self.macroblock_address / self.mb_width);
					self.mb_col = (int)(self.macroblock_address % self.mb_width);
					plm_video_predict_macroblock(self);
					increment--;
				}

				self.macroblock_address++;
			}

			self.mb_row = (int)(self.macroblock_address / self.mb_width);
			self.mb_col = (int)(self.macroblock_address % self.mb_width);
			if (((self.mb_col) >= (self.mb_width)) || ((self.mb_row) >= (self.mb_height)))
			{
				return;
			}

			var table = PLM_VIDEO_MACROBLOCK_TYPE[self.picture_type];
			self.macroblock_type = (int)(plm_buffer_read_vlc(self.buffer, table));
			self.macroblock_intra = (int)(self.macroblock_type & 0x01);
			self.motion_forward.is_set = (int)(self.macroblock_type & 0x08);
			self.motion_backward.is_set = (int)(self.macroblock_type & 0x04);
			if ((self.macroblock_type & 0x10) != 0)
			{
				self.quantizer_scale = (int)(plm_buffer_read(self.buffer, (int)(5)));
			}

			if ((self.macroblock_intra) != 0)
			{
				self.motion_backward.h = (int)(self.motion_forward.h = (int)(0));
				self.motion_backward.v = (int)(self.motion_forward.v = (int)(0));
			}
			else
			{
				self.dc_predictor[0] = (int)(128);
				self.dc_predictor[1] = (int)(128);
				self.dc_predictor[2] = (int)(128);
				plm_video_decode_motion_vectors(self);
				plm_video_predict_macroblock(self);
			}

			int cbp = (int)(((self.macroblock_type & 0x02) != 0) ? plm_buffer_read_vlc(self.buffer, PLM_VIDEO_CODE_BLOCK_PATTERN) : ((self.macroblock_intra) != 0 ? 0x3f : 0));
			int mask = (int)(0x20);
			for (int block = (int)(0); (block) < (6); block++)
			{
				if ((cbp & mask) != 0)
				{
					plm_video_decode_block(self, (int)(block));
				}

				mask >>= 1;
			}
		}
		public static void plm_video_decode_motion_vectors(plm_video_t self)
		{
			if ((self.motion_forward.is_set) != 0)
			{
				int r_size = (int)(self.motion_forward.r_size);
				self.motion_forward.h = (int)(plm_video_decode_motion_vector(self, (int)(r_size), (int)(self.motion_forward.h)));
				self.motion_forward.v = (int)(plm_video_decode_motion_vector(self, (int)(r_size), (int)(self.motion_forward.v)));
			}
			else if ((self.picture_type) == (PLM_VIDEO_PICTURE_TYPE_PREDICTIVE))
			{
				self.motion_forward.h = (int)(0);
				self.motion_forward.v = (int)(0);
			}

			if ((self.motion_backward.is_set) != 0)
			{
				int r_size = (int)(self.motion_backward.r_size);
				self.motion_backward.h = (int)(plm_video_decode_motion_vector(self, (int)(r_size), (int)(self.motion_backward.h)));
				self.motion_backward.v = (int)(plm_video_decode_motion_vector(self, (int)(r_size), (int)(self.motion_backward.v)));
			}
		}
		public static int plm_video_decode_motion_vector(plm_video_t self, int r_size, int motion)
		{
			int fscale = (int)(1 << r_size);
			int m_code = (int)(plm_buffer_read_vlc(self.buffer, PLM_VIDEO_MOTION));
			int r = (int)(0);
			int d = 0;
			if ((m_code != 0) && (fscale != 1))
			{
				r = (int)(plm_buffer_read(self.buffer, (int)(r_size)));
				d = (int)(((CRuntime.abs((int)(m_code)) - 1) << r_size) + r + 1);
				if ((m_code) < (0))
				{
					d = (int)(-d);
				}
			}
			else
			{
				d = (int)(m_code);
			}

			motion += (int)(d);
			if ((motion) > ((fscale << 4) - 1))
			{
				motion -= (int)(fscale << 5);
			}
			else if ((motion) < ((int)((uint)(-fscale) << 4)))
			{
				motion += (int)(fscale << 5);
			}

			return (int)(motion);
		}
		public static void plm_video_predict_macroblock(plm_video_t self)
		{
			int fw_h = (int)(self.motion_forward.h);
			int fw_v = (int)(self.motion_forward.v);
			if ((self.motion_forward.full_px) != 0)
			{
				fw_h <<= 1;
				fw_v <<= 1;
			}

			if ((self.picture_type) == (PLM_VIDEO_PICTURE_TYPE_B))
			{
				int bw_h = (int)(self.motion_backward.h);
				int bw_v = (int)(self.motion_backward.v);
				if ((self.motion_backward.full_px) != 0)
				{
					bw_h <<= 1;
					bw_v <<= 1;
				}

				if ((self.motion_forward.is_set) != 0)
				{
					plm_video_copy_macroblock(self, self.frame_forward, (int)(fw_h), (int)(fw_v));
					if ((self.motion_backward.is_set) != 0)
					{
						plm_video_interpolate_macroblock(self, self.frame_backward, (int)(bw_h), (int)(bw_v));
					}
				}
				else
				{
					plm_video_copy_macroblock(self, self.frame_backward, (int)(bw_h), (int)(bw_v));
				}
			}
			else
			{
				plm_video_copy_macroblock(self, self.frame_forward, (int)(fw_h), (int)(fw_v));
			}
		}
		public static void plm_video_copy_macroblock(plm_video_t self, plm_frame_t s, int motion_h, int motion_v)
		{
			plm_frame_t d = self.frame_current;
			plm_video_process_macroblock(self, s.y.data, d.y.data, (int)(motion_h), (int)(motion_v), (int)(16), (int)(0));
			plm_video_process_macroblock(self, s.cr.data, d.cr.data, (int)(motion_h / 2), (int)(motion_v / 2), (int)(8), (int)(0));
			plm_video_process_macroblock(self, s.cb.data, d.cb.data, (int)(motion_h / 2), (int)(motion_v / 2), (int)(8), (int)(0));
		}
		public static void plm_video_interpolate_macroblock(plm_video_t self, plm_frame_t s, int motion_h, int motion_v)
		{
			plm_frame_t d = self.frame_current;
			plm_video_process_macroblock(self, s.y.data, d.y.data, (int)(motion_h), (int)(motion_v), (int)(16), (int)(1));
			plm_video_process_macroblock(self, s.cr.data, d.cr.data, (int)(motion_h / 2), (int)(motion_v / 2), (int)(8), (int)(1));
			plm_video_process_macroblock(self, s.cb.data, d.cb.data, (int)(motion_h / 2), (int)(motion_v / 2), (int)(8), (int)(1));
		}
		public static void plm_video_process_macroblock(plm_video_t self, byte[] s, byte[] d, int motion_h, int motion_v, int block_size, int interpolate)
		{
			int dw = (int)(self.mb_width * block_size);
			int hp = (int)(motion_h >> 1);
			int vp = (int)(motion_v >> 1);
			int odd_h = (int)((motion_h & 1) == (1) ? 1 : 0);
			int odd_v = (int)((motion_v & 1) == (1) ? 1 : 0);
			uint si = (uint)(((self.mb_row * block_size) + vp) * dw + (self.mb_col * block_size) + hp);
			uint di = (uint)((self.mb_row * dw + self.mb_col) * block_size);
			uint max_address = (uint)(dw * (self.mb_height * block_size - block_size + 1) - block_size);
			if (((si) > (max_address)) || ((di) > (max_address)))
			{
				return;
			}

			switch ((interpolate << 2) | (odd_h << 1) | (odd_v))
			{
				case ((0 << 2) | (0 << 1) | (0)):
					do
					{
						int dest_scan = (int)(dw - block_size);
						int source_scan = (int)(dw - block_size);
						for (int y = (int)(0); (y) < (block_size); y++)
						{
							for (int x = (int)(0); (x) < (block_size); x++)
							{
								d[di] = (byte)(s[si]);
								si++;
								di++;
							}

							si += (uint)(source_scan);
							di += (uint)(dest_scan);
						}
					}
					while ((0) != 0);
					break;
				case ((0 << 2) | (0 << 1) | (1)):
					do
					{
						int dest_scan = (int)(dw - block_size);
						int source_scan = (int)(dw - block_size);
						for (int y = (int)(0); (y) < (block_size); y++)
						{
							for (int x = (int)(0); (x) < (block_size); x++)
							{
								d[di] = (byte)((s[si] + s[si + dw] + 1) >> 1);
								si++;
								di++;
							}

							si += (uint)(source_scan);
							di += (uint)(dest_scan);
						}
					}
					while ((0) != 0);
					break;
				case ((0 << 2) | (1 << 1) | (0)):
					do
					{
						int dest_scan = (int)(dw - block_size);
						int source_scan = (int)(dw - block_size);
						for (int y = (int)(0); (y) < (block_size); y++)
						{
							for (int x = (int)(0); (x) < (block_size); x++)
							{
								d[di] = (byte)((s[si] + s[si + 1] + 1) >> 1);
								si++;
								di++;
							}

							si += (uint)(source_scan);
							di += (uint)(dest_scan);
						}
					}
					while ((0) != 0);
					break;
				case ((0 << 2) | (1 << 1) | (1)):
					do
					{
						int dest_scan = (int)(dw - block_size);
						int source_scan = (int)(dw - block_size);
						for (int y = (int)(0); (y) < (block_size); y++)
						{
							for (int x = (int)(0); (x) < (block_size); x++)
							{
								d[di] = (byte)((s[si] + s[si + 1] + s[si + dw] + s[si + dw + 1] + 2) >> 2);
								si++;
								di++;
							}

							si += (uint)(source_scan);
							di += (uint)(dest_scan);
						}
					}
					while ((0) != 0);
					break;
				case ((1 << 2) | (0 << 1) | (0)):
					do
					{
						int dest_scan = (int)(dw - block_size);
						int source_scan = (int)(dw - block_size);
						for (int y = (int)(0); (y) < (block_size); y++)
						{
							for (int x = (int)(0); (x) < (block_size); x++)
							{
								d[di] = (byte)((d[di] + (s[si]) + 1) >> 1);
								si++;
								di++;
							}

							si += (uint)(source_scan);
							di += (uint)(dest_scan);
						}
					}
					while ((0) != 0);
					break;
				case ((1 << 2) | (0 << 1) | (1)):
					do
					{
						int dest_scan = (int)(dw - block_size);
						int source_scan = (int)(dw - block_size);
						for (int y = (int)(0); (y) < (block_size); y++)
						{
							for (int x = (int)(0); (x) < (block_size); x++)
							{
								d[di] = (byte)((d[di] + ((s[si] + s[si + dw] + 1) >> 1) + 1) >> 1);
								si++;
								di++;
							}

							si += (uint)(source_scan);
							di += (uint)(dest_scan);
						}
					}
					while ((0) != 0);
					break;
				case ((1 << 2) | (1 << 1) | (0)):
					do
					{
						int dest_scan = (int)(dw - block_size);
						int source_scan = (int)(dw - block_size);
						for (int y = (int)(0); (y) < (block_size); y++)
						{
							for (int x = (int)(0); (x) < (block_size); x++)
							{
								d[di] = (byte)((d[di] + ((s[si] + s[si + 1] + 1) >> 1) + 1) >> 1);
								si++;
								di++;
							}

							si += (uint)(source_scan);
							di += (uint)(dest_scan);
						}
					}
					while ((0) != 0);
					break;
				case ((1 << 2) | (1 << 1) | (1)):
					do
					{
						int dest_scan = (int)(dw - block_size);
						int source_scan = (int)(dw - block_size);
						for (int y = (int)(0); (y) < (block_size); y++)
						{
							for (int x = (int)(0); (x) < (block_size); x++)
							{
								d[di] = (byte)((d[di] + ((s[si] + s[si + 1] + s[si + dw] + s[si + dw + 1] + 2) >> 2) + 1) >> 1);
								si++;
								di++;
							}

							si += (uint)(source_scan);
							di += (uint)(dest_scan);
						}
					}
					while ((0) != 0);
					break;
			}
		}
		public static void plm_video_decode_block(plm_video_t self, int block)
		{
			int n = (int)(0);
			byte[] quant_matrix;
			if ((self.macroblock_intra) != 0)
			{
				int predictor = 0;
				int dct_size = 0;
				int plane_index = (int)((block) > (3) ? block - 3 : 0);
				predictor = (int)(self.dc_predictor[plane_index]);
				dct_size = (int)(plm_buffer_read_vlc(self.buffer, PLM_VIDEO_DCT_SIZE[plane_index]));
				if ((dct_size) > (0))
				{
					int differential = (int)(plm_buffer_read(self.buffer, (int)(dct_size)));
					if ((differential & (1 << (dct_size - 1))) != 0)
					{
						self.block_data[0] = (int)(predictor + differential);
					}
					else
					{
						self.block_data[0] = (int)(predictor + (-(1 << dct_size) | (differential + 1)));
					}
				}
				else
				{
					self.block_data[0] = (int)(predictor);
				}

				self.dc_predictor[plane_index] = (int)(self.block_data[0]);
				self.block_data[0] <<= (3 + 5);
				quant_matrix = self.intra_quant_matrix;
				n = (int)(1);
			}
			else
			{
				quant_matrix = self.non_intra_quant_matrix;
			}

			int level = (int)(0);
			while ((1) != 0)
			{
				int run = (int)(0);
				ushort coeff = (ushort)(plm_buffer_read_vlc_uint(self.buffer, PLM_VIDEO_DCT_COEFF));
				if ((((coeff) == (0x0001)) && ((n) > (0))) && ((plm_buffer_read(self.buffer, (int)(1))) == (0)))
				{
					break;
				}

				if ((coeff) == (0xffff))
				{
					run = (int)(plm_buffer_read(self.buffer, (int)(6)));
					level = (int)(plm_buffer_read(self.buffer, (int)(8)));
					if ((level) == (0))
					{
						level = (int)(plm_buffer_read(self.buffer, (int)(8)));
					}
					else if ((level) == (128))
					{
						level = (int)(plm_buffer_read(self.buffer, (int)(8)) - 256);
					}
					else if ((level) > (128))
					{
						level = (int)(level - 256);
					}
				}
				else
				{
					run = (int)(coeff >> 8);
					level = (int)(coeff & 0xff);
					if ((plm_buffer_read(self.buffer, (int)(1))) != 0)
					{
						level = (int)(-level);
					}
				}

				n += (int)(run);
				if (((n) < (0)) || ((n) >= (64)))
				{
					return;
				}

				int de_zig_zagged = (int)(PLM_VIDEO_ZIG_ZAG[n]);
				n++;
				level = (int)((uint)(level) << 1);
				if (self.macroblock_intra == 0)
				{
					level += (int)((level) < (0) ? -1 : 1);
				}

				level = (int)((level * self.quantizer_scale * quant_matrix[de_zig_zagged]) >> 4);
				if ((level & 1) == (0))
				{
					level -= (int)((level) > (0) ? 1 : -1);
				}

				if ((level) > (2047))
				{
					level = (int)(2047);
				}
				else if ((level) < (-2048))
				{
					level = (int)(-2048);
				}

				self.block_data[de_zig_zagged] = (int)(level * PLM_VIDEO_PREMULTIPLIER_MATRIX[de_zig_zagged]);
			}

			byte[] d;
			int dw = 0;
			int di = 0;
			if ((block) < (4))
			{
				d = self.frame_current.y.data;
				dw = (int)(self.luma_width);
				di = (int)((self.mb_row * self.luma_width + self.mb_col) << 4);
				if ((block & 1) != 0)
				{
					di += (int)(8);
				}

				if ((block & 2) != 0)
				{
					di += (int)(self.luma_width << 3);
				}
			}
			else
			{
				d = ((block) == (4)) ? self.frame_current.cb.data : self.frame_current.cr.data;
				dw = (int)(self.chroma_width);
				di = (int)(((self.mb_row * self.luma_width) << 2) + (self.mb_col << 3));
			}

			var s = self.block_data;
			int si = (int)(0);
			if ((self.macroblock_intra) != 0)
			{
				if ((n) == (1))
				{
					int clamped = (int)(plm_clamp((int)((s[0] + 128) >> 8)));
					do
					{
						int dest_scan = (int)(dw - 8);
						int source_scan = (int)(8 - 8);
						for (int y = (int)(0); (y) < (8); y++)
						{
							for (int x = (int)(0); (x) < (8); x++)
							{
								d[di] = (byte)(clamped);
								si++;
								di++;
							}

							si += (int)(source_scan);
							di += (int)(dest_scan);
						}
					}
					while ((0) != 0);
					s[0] = (int)(0);
				}
				else
				{
					plm_video_idct(s);
					do
					{
						int dest_scan = (int)(dw - 8);
						int source_scan = (int)(8 - 8);
						for (int y = (int)(0); (y) < (8); y++)
						{
							for (int x = (int)(0); (x) < (8); x++)
							{
								d[di] = (byte)(plm_clamp((int)(s[si])));
								si++;
								di++;
							}

							si += (int)(source_scan);
							di += (int)(dest_scan);
						}
					}
					while ((0) != 0);
					self.block_data.ArraySet(0);
				}
			}
			else
			{
				if ((n) == (1))
				{
					int value = (int)((s[0] + 128) >> 8);
					do
					{
						int dest_scan = (int)(dw - 8);
						int source_scan = (int)(8 - 8);
						for (int y = (int)(0); (y) < (8); y++)
						{
							for (int x = (int)(0); (x) < (8); x++)
							{
								d[di] = (byte)(plm_clamp((int)(d[di] + value)));
								si++;
								di++;
							}

							si += (int)(source_scan);
							di += (int)(dest_scan);
						}
					}
					while ((0) != 0);
					s[0] = (int)(0);
				}
				else
				{
					plm_video_idct(s);
					do
					{
						int dest_scan = (int)(dw - 8);
						int source_scan = (int)(8 - 8);
						for (int y = (int)(0); (y) < (8); y++)
						{
							for (int x = (int)(0); (x) < (8); x++)
							{
								d[di] = (byte)(plm_clamp((int)(d[di] + s[si])));
								si++;
								di++;
							}

							si += (int)(source_scan);
							di += (int)(dest_scan);
						}
					}
					while ((0) != 0);
					self.block_data.ArraySet(0);
				}
			}
		}
		public static void plm_video_idct(int[] block)
		{
			int b1 = 0; int b3 = 0; int b4 = 0; int b6 = 0; int b7 = 0; int tmp1 = 0; int tmp2 = 0; int m0 = 0; int x0 = 0; int x1 = 0; int x2 = 0; int x3 = 0; int x4 = 0; int y3 = 0; int y4 = 0; int y5 = 0; int y6 = 0; int y7 = 0;
			for (int i = (int)(0); (i) < (8); ++i)
			{
				b1 = (int)(block[4 * 8 + i]);
				b3 = (int)(block[2 * 8 + i] + block[6 * 8 + i]);
				b4 = (int)(block[5 * 8 + i] - block[3 * 8 + i]);
				tmp1 = (int)(block[1 * 8 + i] + block[7 * 8 + i]);
				tmp2 = (int)(block[3 * 8 + i] + block[5 * 8 + i]);
				b6 = (int)(block[1 * 8 + i] - block[7 * 8 + i]);
				b7 = (int)(tmp1 + tmp2);
				m0 = (int)(block[0 * 8 + i]);
				x4 = (int)(((b6 * 473 - b4 * 196 + 128) >> 8) - b7);
				x0 = (int)(x4 - (((tmp1 - tmp2) * 362 + 128) >> 8));
				x1 = (int)(m0 - b1);
				x2 = (int)((((block[2 * 8 + i] - block[6 * 8 + i]) * 362 + 128) >> 8) - b3);
				x3 = (int)(m0 + b1);
				y3 = (int)(x1 + x2);
				y4 = (int)(x3 + b3);
				y5 = (int)(x1 - x2);
				y6 = (int)(x3 - b3);
				y7 = (int)(-x0 - ((b4 * 473 + b6 * 196 + 128) >> 8));
				block[0 * 8 + i] = (int)(b7 + y4);
				block[1 * 8 + i] = (int)(x4 + y3);
				block[2 * 8 + i] = (int)(y5 - x0);
				block[3 * 8 + i] = (int)(y6 - y7);
				block[4 * 8 + i] = (int)(y6 + y7);
				block[5 * 8 + i] = (int)(x0 + y5);
				block[6 * 8 + i] = (int)(y3 - x4);
				block[7 * 8 + i] = (int)(y4 - b7);
			}

			for (int i = (int)(0); (i) < (64); i += (int)(8))
			{
				b1 = (int)(block[4 + i]);
				b3 = (int)(block[2 + i] + block[6 + i]);
				b4 = (int)(block[5 + i] - block[3 + i]);
				tmp1 = (int)(block[1 + i] + block[7 + i]);
				tmp2 = (int)(block[3 + i] + block[5 + i]);
				b6 = (int)(block[1 + i] - block[7 + i]);
				b7 = (int)(tmp1 + tmp2);
				m0 = (int)(block[0 + i]);
				x4 = (int)(((b6 * 473 - b4 * 196 + 128) >> 8) - b7);
				x0 = (int)(x4 - (((tmp1 - tmp2) * 362 + 128) >> 8));
				x1 = (int)(m0 - b1);
				x2 = (int)((((block[2 + i] - block[6 + i]) * 362 + 128) >> 8) - b3);
				x3 = (int)(m0 + b1);
				y3 = (int)(x1 + x2);
				y4 = (int)(x3 + b3);
				y5 = (int)(x1 - x2);
				y6 = (int)(x3 - b3);
				y7 = (int)(-x0 - ((b4 * 473 + b6 * 196 + 128) >> 8));
				block[0 + i] = (int)((b7 + y4 + 128) >> 8);
				block[1 + i] = (int)((x4 + y3 + 128) >> 8);
				block[2 + i] = (int)((y5 - x0 + 128) >> 8);
				block[3 + i] = (int)((y6 - y7 + 128) >> 8);
				block[4 + i] = (int)((y6 + y7 + 128) >> 8);
				block[5 + i] = (int)((x0 + y5 + 128) >> 8);
				block[6 + i] = (int)((y3 - x4 + 128) >> 8);
				block[7 + i] = (int)((y4 - b7 + 128) >> 8);
			}
		}
		public static int plm_audio_find_frame_sync(plm_audio_t self)
		{
			ulong i = 0;
			for (i = (ulong)(self.buffer.bit_index >> 3); (i) < (self.buffer.length - 1); i++)
			{
				if (((self.buffer.bytes[i]) == (0xFF)) && ((self.buffer.bytes[i + 1] & 0xFE) == (0xFC)))
				{
					self.buffer.bit_index = (ulong)(((i + 1) << 3) + 3);
					return (int)(1);
				}
			}

			self.buffer.bit_index = (ulong)((i + 1) << 3);
			return (int)(0);
		}
		public static int plm_audio_decode_header(plm_audio_t self)
		{
			if (plm_buffer_has(self.buffer, (ulong)(48)) == 0)
			{
				return (int)(0);
			}

			plm_buffer_skip_bytes(self.buffer, (byte)(0x00));
			int sync = (int)(plm_buffer_read(self.buffer, (int)(11)));
			if ((sync != PLM_AUDIO_FRAME_SYNC) && (plm_audio_find_frame_sync(self) == 0))
			{
				return (int)(0);
			}

			self.version = (int)(plm_buffer_read(self.buffer, (int)(2)));
			self.layer = (int)(plm_buffer_read(self.buffer, (int)(2)));
			var hasCRC = plm_buffer_read(self.buffer, (int)(1)) == 0;
			if ((self.version != PLM_AUDIO_MPEG_1) || (self.layer != PLM_AUDIO_LAYER_II))
			{
				return (int)(0);
			}

			int bitrate_index = (int)(plm_buffer_read(self.buffer, (int)(4)) - 1);
			if ((bitrate_index) > (13))
			{
				return (int)(0);
			}

			int samplerate_index = (int)(plm_buffer_read(self.buffer, (int)(2)));
			if ((samplerate_index) == (3))
			{
				return (int)(0);
			}

			int padding = (int)(plm_buffer_read(self.buffer, (int)(1)));
			plm_buffer_skip(self.buffer, (ulong)(1));
			int mode = (int)(plm_buffer_read(self.buffer, (int)(2)));
			if (((self.has_header) != 0) && (((self.bitrate_index != bitrate_index) || (self.samplerate_index != samplerate_index)) || (self.mode != mode)))
			{
				return (int)(0);
			}

			self.bitrate_index = (int)(bitrate_index);
			self.samplerate_index = (int)(samplerate_index);
			self.mode = (int)(mode);
			self.has_header = (int)(1);
			if ((mode) == (PLM_AUDIO_MODE_JOINT_STEREO))
			{
				self.bound = (int)((plm_buffer_read(self.buffer, (int)(2)) + 1) << 2);
			}
			else
			{
				plm_buffer_skip(self.buffer, (ulong)(2));
				self.bound = (int)(((mode) == (PLM_AUDIO_MODE_MONO)) ? 0 : 32);
			}

			plm_buffer_skip(self.buffer, (ulong)(4));
			if (hasCRC)
			{
				plm_buffer_skip(self.buffer, (ulong)(16));
			}

			int bitrate = (int)(PLM_AUDIO_BIT_RATE[self.bitrate_index]);
			int samplerate = (int)(PLM_AUDIO_SAMPLE_RATE[self.samplerate_index]);
			int frame_size = (int)((144000 * bitrate / samplerate) + padding);
			return (int)(frame_size - (hasCRC ? 6 : 4));
		}
		public static void plm_audio_decode_frame(plm_audio_t self)
		{
			int tab3 = (int)(0);
			int sblimit = (int)(0);
			int tab1 = (int)(((self.mode) == (PLM_AUDIO_MODE_MONO)) ? 0 : 1);
			int tab2 = (int)(PLM_AUDIO_QUANT_LUT_STEP_1[tab1, self.bitrate_index]);
			tab3 = (int)(QUANT_LUT_STEP_2[tab2, self.samplerate_index]);
			sblimit = (int)(tab3 & 63);
			tab3 >>= 6;
			if ((self.bound) > (sblimit))
			{
				self.bound = (int)(sblimit);
			}

			for (int sb = (int)(0); (sb) < (self.bound); sb++)
			{
				self.allocation[0, sb] = plm_audio_read_allocation(self, (int)(sb), (int)(tab3));
				self.allocation[1, sb] = plm_audio_read_allocation(self, (int)(sb), (int)(tab3));
			}

			for (int sb = (int)(self.bound); (sb) < (sblimit); sb++)
			{
				self.allocation[0, sb] = self.allocation[1, sb] = plm_audio_read_allocation(self, (int)(sb), (int)(tab3));
			}

			int channels = (int)(((self.mode) == (PLM_AUDIO_MODE_MONO)) ? 1 : 2);
			for (int sb = (int)(0); (sb) < (sblimit); sb++)
			{
				for (int ch = (int)(0); (ch) < (channels); ch++)
				{
					if ((self.allocation[ch, sb]) != null)
					{
						self.scale_factor_info[ch, sb] = (byte)(plm_buffer_read(self.buffer, (int)(2)));
					}
				}

				if ((self.mode) == (PLM_AUDIO_MODE_MONO))
				{
					self.scale_factor_info[1, sb] = (byte)(self.scale_factor_info[0, sb]);
				}
			}

			for (int sb = (int)(0); (sb) < (sblimit); sb++)
			{
				for (int ch = (int)(0); (ch) < (channels); ch++)
				{
					if ((self.allocation[ch, sb]) != null)
					{

						switch (self.scale_factor_info[ch, sb])
						{
							case 0:
								self.scale_factor[ch, sb, 0] = (int)(plm_buffer_read(self.buffer, (int)(6)));
								self.scale_factor[ch, sb, 1] = (int)(plm_buffer_read(self.buffer, (int)(6)));
								self.scale_factor[ch, sb, 2] = (int)(plm_buffer_read(self.buffer, (int)(6)));
								break;
							case 1:
								self.scale_factor[ch, sb, 0] = (int)(self.scale_factor[ch, sb, 1] = (int)(plm_buffer_read(self.buffer, (int)(6))));
								self.scale_factor[ch, sb, 2] = (int)(plm_buffer_read(self.buffer, (int)(6)));
								break;
							case 2:
								self.scale_factor[ch, sb, 0] = (int)(self.scale_factor[ch, sb, 1] = (int)(self.scale_factor[ch, sb, 2] = (int)(plm_buffer_read(self.buffer, (int)(6)))));
								break;
							case 3:
								self.scale_factor[ch, sb, 0] = (int)(plm_buffer_read(self.buffer, (int)(6)));
								self.scale_factor[ch, sb, 1] = (int)(self.scale_factor[ch, sb, 2] = (int)(plm_buffer_read(self.buffer, (int)(6))));
								break;
						}
					}
				}

				if ((self.mode) == (PLM_AUDIO_MODE_MONO))
				{
					self.scale_factor[1, sb, 0] = (int)(self.scale_factor[0, sb, 0]);
					self.scale_factor[1, sb, 1] = (int)(self.scale_factor[0, sb, 1]);
					self.scale_factor[1, sb, 2] = (int)(self.scale_factor[0, sb, 2]);
				}
			}

			int out_pos = (int)(0);
			for (int part = (int)(0); (part) < (3); part++)
			{
				for (int granule = (int)(0); (granule) < (4); granule++)
				{
					for (int sb = (int)(0); (sb) < (self.bound); sb++)
					{
						plm_audio_read_samples(self, (int)(0), (int)(sb), (int)(part));
						plm_audio_read_samples(self, (int)(1), (int)(sb), (int)(part));
					}

					for (int sb = (int)(self.bound); (sb) < (sblimit); sb++)
					{
						plm_audio_read_samples(self, (int)(0), (int)(sb), (int)(part));
						self.sample[1][sb][0] = (int)(self.sample[0][sb][0]);
						self.sample[1][sb][1] = (int)(self.sample[0][sb][1]);
						self.sample[1][sb][2] = (int)(self.sample[0][sb][2]);
					}

					for (int sb = (int)(sblimit); (sb) < (32); sb++)
					{
						self.sample[0][sb][0] = (int)(0);
						self.sample[0][sb][1] = (int)(0);
						self.sample[0][sb][2] = (int)(0);
						self.sample[1][sb][0] = (int)(0);
						self.sample[1][sb][1] = (int)(0);
						self.sample[1][sb][2] = (int)(0);
					}

					for (int p = (int)(0); (p) < (3); p++)
					{
						self.v_pos = (int)((self.v_pos - 64) & 1023);
						for (int ch = (int)(0); (ch) < (2); ch++)
						{
							plm_audio_idct36(self.sample[ch], (int)(p), self.V[ch], (int)(self.v_pos));
							self.U.ArraySet(0);
							int d_index = (int)(512 - (self.v_pos >> 1));
							int v_index = (int)((self.v_pos % 128) >> 1);
							while ((v_index) < (1024))
							{
								for (int i = (int)(0); (i) < (32); ++i)
								{
									self.U[i] += (float)(self.D[d_index++] * self.V[ch][v_index++]);
								}

								v_index += (int)(128 - 32);
								d_index += (int)(64 - 32);
							}

							d_index -= (int)(512 - 32);
							v_index = (int)((128 - 32 + 1024) - v_index);
							while ((v_index) < (1024))
							{
								for (int i = (int)(0); (i) < (32); ++i)
								{
									self.U[i] += (float)(self.D[d_index++] * self.V[ch][v_index++]);
								}

								v_index += (int)(128 - 32);
								d_index += (int)(64 - 32);
							}

							for (int j = (int)(0); (j) < (32); j++)
							{
								self.samples.interleaved[((out_pos + j) << 1) + ch] = (float)(self.U[j] / -1090519040.0f);
							}
						}

						out_pos += (int)(32);
					}
				}
			}

			plm_buffer_align(self.buffer);
		}
		public static plm_quantizer_spec_t? plm_audio_read_allocation(plm_audio_t self, int sb, int tab3)
		{
			int tab4 = (int)(PLM_AUDIO_QUANT_LUT_STEP_3[tab3, sb]);
			int qtab = (int)(PLM_AUDIO_QUANT_LUT_STEP_4[tab4 & 15, plm_buffer_read(self.buffer, (int)(tab4 >> 4))]);
			return (qtab) != 0 ? (PLM_AUDIO_QUANT_TAB[qtab - 1]) : (plm_quantizer_spec_t?)null;
		}
		public static void plm_audio_read_samples(plm_audio_t self, int ch, int sb, int part)
		{
			plm_quantizer_spec_t? qq = self.allocation[ch, sb];
			int sf = (int)(self.scale_factor[ch, sb, part]);
			var sample = self.sample[ch][sb];
			int val = (int)(0);
			if (qq == null)
			{
				sample[0] = (int)(sample[1] = (int)(sample[2] = (int)(0)));
				return;
			}

			if ((sf) == (63))
			{
				sf = (int)(0);
			}
			else
			{
				int shift = (int)((sf / 3) | 0);
				sf = (int)((PLM_AUDIO_SCALEFACTOR_BASE[sf % 3] + ((1 << shift) >> 1)) >> shift);
			}

			var q = qq.Value;
			int adj = (int)(q.levels);
			if ((q.group) != 0)
			{
				val = (int)(plm_buffer_read(self.buffer, (int)(q.bits)));
				sample[0] = (int)(val % adj);
				val /= (int)(adj);
				sample[1] = (int)(val % adj);
				sample[2] = (int)(val / adj);
			}
			else
			{
				sample[0] = (int)(plm_buffer_read(self.buffer, (int)(q.bits)));
				sample[1] = (int)(plm_buffer_read(self.buffer, (int)(q.bits)));
				sample[2] = (int)(plm_buffer_read(self.buffer, (int)(q.bits)));
			}

			int scale = (int)(65536 / (adj + 1));
			adj = (int)(((adj + 1) >> 1) - 1);
			val = (int)((adj - sample[0]) * scale);
			sample[0] = (int)((val * (sf >> 12) + ((val * (sf & 4095) + 2048) >> 12)) >> 12);
			val = (int)((adj - sample[1]) * scale);
			sample[1] = (int)((val * (sf >> 12) + ((val * (sf & 4095) + 2048) >> 12)) >> 12);
			val = (int)((adj - sample[2]) * scale);
			sample[2] = (int)((val * (sf >> 12) + ((val * (sf & 4095) + 2048) >> 12)) >> 12);
		}
		public static void plm_audio_idct36(int[][] s, int ss, float[] d, int dp)
		{
			float t01 = 0; float t02 = 0; float t03 = 0; float t04 = 0; float t05 = 0; float t06 = 0; float t07 = 0; float t08 = 0; float t09 = 0; float t10 = 0; float t11 = 0; float t12 = 0; float t13 = 0; float t14 = 0; float t15 = 0; float t16 = 0; float t17 = 0; float t18 = 0; float t19 = 0; float t20 = 0; float t21 = 0; float t22 = 0; float t23 = 0; float t24 = 0; float t25 = 0; float t26 = 0; float t27 = 0; float t28 = 0; float t29 = 0; float t30 = 0; float t31 = 0; float t32 = 0; float t33 = 0;
			t01 = ((float)(s[0][ss] + s[31][ss]));
			t02 = (float)((float)(s[0][ss] - s[31][ss]) * 0.500602998235f);
			t03 = ((float)(s[1][ss] + s[30][ss]));
			t04 = (float)((float)(s[1][ss] - s[30][ss]) * 0.505470959898f);
			t05 = ((float)(s[2][ss] + s[29][ss]));
			t06 = (float)((float)(s[2][ss] - s[29][ss]) * 0.515447309923f);
			t07 = ((float)(s[3][ss] + s[28][ss]));
			t08 = (float)((float)(s[3][ss] - s[28][ss]) * 0.53104259109f);
			t09 = ((float)(s[4][ss] + s[27][ss]));
			t10 = (float)((float)(s[4][ss] - s[27][ss]) * 0.553103896034f);
			t11 = ((float)(s[5][ss] + s[26][ss]));
			t12 = (float)((float)(s[5][ss] - s[26][ss]) * 0.582934968206f);
			t13 = ((float)(s[6][ss] + s[25][ss]));
			t14 = (float)((float)(s[6][ss] - s[25][ss]) * 0.622504123036f);
			t15 = ((float)(s[7][ss] + s[24][ss]));
			t16 = (float)((float)(s[7][ss] - s[24][ss]) * 0.674808341455f);
			t17 = ((float)(s[8][ss] + s[23][ss]));
			t18 = (float)((float)(s[8][ss] - s[23][ss]) * 0.744536271002f);
			t19 = ((float)(s[9][ss] + s[22][ss]));
			t20 = (float)((float)(s[9][ss] - s[22][ss]) * 0.839349645416f);
			t21 = ((float)(s[10][ss] + s[21][ss]));
			t22 = (float)((float)(s[10][ss] - s[21][ss]) * 0.972568237862f);
			t23 = ((float)(s[11][ss] + s[20][ss]));
			t24 = (float)((float)(s[11][ss] - s[20][ss]) * 1.16943993343f);
			t25 = ((float)(s[12][ss] + s[19][ss]));
			t26 = (float)((float)(s[12][ss] - s[19][ss]) * 1.48416461631f);
			t27 = ((float)(s[13][ss] + s[18][ss]));
			t28 = (float)((float)(s[13][ss] - s[18][ss]) * 2.05778100995f);
			t29 = ((float)(s[14][ss] + s[17][ss]));
			t30 = (float)((float)(s[14][ss] - s[17][ss]) * 3.40760841847f);
			t31 = ((float)(s[15][ss] + s[16][ss]));
			t32 = (float)((float)(s[15][ss] - s[16][ss]) * 10.1900081235f);
			t33 = (float)(t01 + t31);
			t31 = (float)((t01 - t31) * 0.502419286188f);
			t01 = (float)(t03 + t29);
			t29 = (float)((t03 - t29) * 0.52249861494f);
			t03 = (float)(t05 + t27);
			t27 = (float)((t05 - t27) * 0.566944034816f);
			t05 = (float)(t07 + t25);
			t25 = (float)((t07 - t25) * 0.64682178336f);
			t07 = (float)(t09 + t23);
			t23 = (float)((t09 - t23) * 0.788154623451f);
			t09 = (float)(t11 + t21);
			t21 = (float)((t11 - t21) * 1.06067768599f);
			t11 = (float)(t13 + t19);
			t19 = (float)((t13 - t19) * 1.72244709824f);
			t13 = (float)(t15 + t17);
			t17 = (float)((t15 - t17) * 5.10114861869f);
			t15 = (float)(t33 + t13);
			t13 = (float)((t33 - t13) * 0.509795579104f);
			t33 = (float)(t01 + t11);
			t01 = (float)((t01 - t11) * 0.601344886935f);
			t11 = (float)(t03 + t09);
			t09 = (float)((t03 - t09) * 0.899976223136f);
			t03 = (float)(t05 + t07);
			t07 = (float)((t05 - t07) * 2.56291544774f);
			t05 = (float)(t15 + t03);
			t15 = (float)((t15 - t03) * 0.541196100146f);
			t03 = (float)(t33 + t11);
			t11 = (float)((t33 - t11) * 1.30656296488f);
			t33 = (float)(t05 + t03);
			t05 = (float)((t05 - t03) * 0.707106781187f);
			t03 = (float)(t15 + t11);
			t15 = (float)((t15 - t11) * 0.707106781187f);
			t03 += (float)(t15);
			t11 = (float)(t13 + t07);
			t13 = (float)((t13 - t07) * 0.541196100146f);
			t07 = (float)(t01 + t09);
			t09 = (float)((t01 - t09) * 1.30656296488f);
			t01 = (float)(t11 + t07);
			t07 = (float)((t11 - t07) * 0.707106781187f);
			t11 = (float)(t13 + t09);
			t13 = (float)((t13 - t09) * 0.707106781187f);
			t11 += (float)(t13);
			t01 += (float)(t11);
			t11 += (float)(t07);
			t07 += (float)(t13);
			t09 = (float)(t31 + t17);
			t31 = (float)((t31 - t17) * 0.509795579104f);
			t17 = (float)(t29 + t19);
			t29 = (float)((t29 - t19) * 0.601344886935f);
			t19 = (float)(t27 + t21);
			t21 = (float)((t27 - t21) * 0.899976223136f);
			t27 = (float)(t25 + t23);
			t23 = (float)((t25 - t23) * 2.56291544774f);
			t25 = (float)(t09 + t27);
			t09 = (float)((t09 - t27) * 0.541196100146f);
			t27 = (float)(t17 + t19);
			t19 = (float)((t17 - t19) * 1.30656296488f);
			t17 = (float)(t25 + t27);
			t27 = (float)((t25 - t27) * 0.707106781187f);
			t25 = (float)(t09 + t19);
			t19 = (float)((t09 - t19) * 0.707106781187f);
			t25 += (float)(t19);
			t09 = (float)(t31 + t23);
			t31 = (float)((t31 - t23) * 0.541196100146f);
			t23 = (float)(t29 + t21);
			t21 = (float)((t29 - t21) * 1.30656296488f);
			t29 = (float)(t09 + t23);
			t23 = (float)((t09 - t23) * 0.707106781187f);
			t09 = (float)(t31 + t21);
			t31 = (float)((t31 - t21) * 0.707106781187f);
			t09 += (float)(t31);
			t29 += (float)(t09);
			t09 += (float)(t23);
			t23 += (float)(t31);
			t17 += (float)(t29);
			t29 += (float)(t25);
			t25 += (float)(t09);
			t09 += (float)(t27);
			t27 += (float)(t23);
			t23 += (float)(t19);
			t19 += (float)(t31);
			t21 = (float)(t02 + t32);
			t02 = (float)((t02 - t32) * 0.502419286188f);
			t32 = (float)(t04 + t30);
			t04 = (float)((t04 - t30) * 0.52249861494f);
			t30 = (float)(t06 + t28);
			t28 = (float)((t06 - t28) * 0.566944034816f);
			t06 = (float)(t08 + t26);
			t08 = (float)((t08 - t26) * 0.64682178336f);
			t26 = (float)(t10 + t24);
			t10 = (float)((t10 - t24) * 0.788154623451f);
			t24 = (float)(t12 + t22);
			t22 = (float)((t12 - t22) * 1.06067768599f);
			t12 = (float)(t14 + t20);
			t20 = (float)((t14 - t20) * 1.72244709824f);
			t14 = (float)(t16 + t18);
			t16 = (float)((t16 - t18) * 5.10114861869f);
			t18 = (float)(t21 + t14);
			t14 = (float)((t21 - t14) * 0.509795579104f);
			t21 = (float)(t32 + t12);
			t32 = (float)((t32 - t12) * 0.601344886935f);
			t12 = (float)(t30 + t24);
			t24 = (float)((t30 - t24) * 0.899976223136f);
			t30 = (float)(t06 + t26);
			t26 = (float)((t06 - t26) * 2.56291544774f);
			t06 = (float)(t18 + t30);
			t18 = (float)((t18 - t30) * 0.541196100146f);
			t30 = (float)(t21 + t12);
			t12 = (float)((t21 - t12) * 1.30656296488f);
			t21 = (float)(t06 + t30);
			t30 = (float)((t06 - t30) * 0.707106781187f);
			t06 = (float)(t18 + t12);
			t12 = (float)((t18 - t12) * 0.707106781187f);
			t06 += (float)(t12);
			t18 = (float)(t14 + t26);
			t26 = (float)((t14 - t26) * 0.541196100146f);
			t14 = (float)(t32 + t24);
			t24 = (float)((t32 - t24) * 1.30656296488f);
			t32 = (float)(t18 + t14);
			t14 = (float)((t18 - t14) * 0.707106781187f);
			t18 = (float)(t26 + t24);
			t24 = (float)((t26 - t24) * 0.707106781187f);
			t18 += (float)(t24);
			t32 += (float)(t18);
			t18 += (float)(t14);
			t26 = (float)(t14 + t24);
			t14 = (float)(t02 + t16);
			t02 = (float)((t02 - t16) * 0.509795579104f);
			t16 = (float)(t04 + t20);
			t04 = (float)((t04 - t20) * 0.601344886935f);
			t20 = (float)(t28 + t22);
			t22 = (float)((t28 - t22) * 0.899976223136f);
			t28 = (float)(t08 + t10);
			t10 = (float)((t08 - t10) * 2.56291544774f);
			t08 = (float)(t14 + t28);
			t14 = (float)((t14 - t28) * 0.541196100146f);
			t28 = (float)(t16 + t20);
			t20 = (float)((t16 - t20) * 1.30656296488f);
			t16 = (float)(t08 + t28);
			t28 = (float)((t08 - t28) * 0.707106781187f);
			t08 = (float)(t14 + t20);
			t20 = (float)((t14 - t20) * 0.707106781187f);
			t08 += (float)(t20);
			t14 = (float)(t02 + t10);
			t02 = (float)((t02 - t10) * 0.541196100146f);
			t10 = (float)(t04 + t22);
			t22 = (float)((t04 - t22) * 1.30656296488f);
			t04 = (float)(t14 + t10);
			t10 = (float)((t14 - t10) * 0.707106781187f);
			t14 = (float)(t02 + t22);
			t02 = (float)((t02 - t22) * 0.707106781187f);
			t14 += (float)(t02);
			t04 += (float)(t14);
			t14 += (float)(t10);
			t10 += (float)(t02);
			t16 += (float)(t04);
			t04 += (float)(t08);
			t08 += (float)(t14);
			t14 += (float)(t28);
			t28 += (float)(t10);
			t10 += (float)(t20);
			t20 += (float)(t02);
			t21 += (float)(t16);
			t16 += (float)(t32);
			t32 += (float)(t04);
			t04 += (float)(t06);
			t06 += (float)(t08);
			t08 += (float)(t18);
			t18 += (float)(t14);
			t14 += (float)(t30);
			t30 += (float)(t28);
			t28 += (float)(t26);
			t26 += (float)(t10);
			t10 += (float)(t12);
			t12 += (float)(t20);
			t20 += (float)(t24);
			t24 += (float)(t02);
			d[dp + 48] = (float)(-t33);
			d[dp + 49] = (float)(d[dp + 47] = (float)(-t21));
			d[dp + 50] = (float)(d[dp + 46] = (float)(-t17));
			d[dp + 51] = (float)(d[dp + 45] = (float)(-t16));
			d[dp + 52] = (float)(d[dp + 44] = (float)(-t01));
			d[dp + 53] = (float)(d[dp + 43] = (float)(-t32));
			d[dp + 54] = (float)(d[dp + 42] = (float)(-t29));
			d[dp + 55] = (float)(d[dp + 41] = (float)(-t04));
			d[dp + 56] = (float)(d[dp + 40] = (float)(-t03));
			d[dp + 57] = (float)(d[dp + 39] = (float)(-t06));
			d[dp + 58] = (float)(d[dp + 38] = (float)(-t25));
			d[dp + 59] = (float)(d[dp + 37] = (float)(-t08));
			d[dp + 60] = (float)(d[dp + 36] = (float)(-t11));
			d[dp + 61] = (float)(d[dp + 35] = (float)(-t18));
			d[dp + 62] = (float)(d[dp + 34] = (float)(-t09));
			d[dp + 63] = (float)(d[dp + 33] = (float)(-t14));
			d[dp + 32] = (float)(-t05);
			d[dp + 0] = (float)(t05);
			d[dp + 31] = (float)(-t30);
			d[dp + 1] = (float)(t30);
			d[dp + 30] = (float)(-t27);
			d[dp + 2] = (float)(t27);
			d[dp + 29] = (float)(-t28);
			d[dp + 3] = (float)(t28);
			d[dp + 28] = (float)(-t07);
			d[dp + 4] = (float)(t07);
			d[dp + 27] = (float)(-t26);
			d[dp + 5] = (float)(t26);
			d[dp + 26] = (float)(-t23);
			d[dp + 6] = (float)(t23);
			d[dp + 25] = (float)(-t10);
			d[dp + 7] = (float)(t10);
			d[dp + 24] = (float)(-t15);
			d[dp + 8] = (float)(t15);
			d[dp + 23] = (float)(-t12);
			d[dp + 9] = (float)(t12);
			d[dp + 22] = (float)(-t19);
			d[dp + 10] = (float)(t19);
			d[dp + 21] = (float)(-t20);
			d[dp + 11] = (float)(t20);
			d[dp + 20] = (float)(-t13);
			d[dp + 12] = (float)(t13);
			d[dp + 19] = (float)(-t24);
			d[dp + 13] = (float)(t24);
			d[dp + 18] = (float)(-t31);
			d[dp + 14] = (float)(t31);
			d[dp + 17] = (float)(-t02);
			d[dp + 15] = (float)(t02);
			d[dp + 16] = (float)(0.0);
		}
	}
}